
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta charset="UTF-8" />
    <title>faw_rockpaperscissors: p2p (manual signaling)</title>
    <link rel="icon" href="../icon.png">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #121212; color: #ddd; margin: 0; padding: 20px; }
        h1, h2, h3 { color: #aaddff; text-shadow: 0 0 6px #88ccff88; }
        h1 { margin-bottom: 20px; } h2 { margin-top: 0; margin-bottom: 15px; } h3 { margin-top: 0; margin-bottom: 10px; }

        .screen { padding: 20px; margin: 0 auto; max-width: 600px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; }
        #roleSelectionScreen, #p2pControlsScreen { margin-bottom: 20px; }
        
        .p2p-step { border: 1px solid #444; padding: 15px; margin-top:15px; border-radius: 5px; background-color: #222; }
        .p2p-instruction { font-size: 0.95em; color: #cceeff; margin-bottom: 10px; line-height: 1.4; }
        .p2p-step textarea { width: calc(100% - 22px); min-height: 70px; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #555; background-color: #333; color: #eee; font-family: monospace; resize: vertical; box-sizing: border-box; }
        .p2p-step button, .screen button, #toggleMuteBtnContainer button { font-size: 1rem; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; background-color: #4CAF50; color: white; transition: background-color 0.3s; width: auto; margin-top: 5px; margin-right: 10px; }
        .p2p-step button.secondary, .screen button.secondary, #toggleMuteBtnContainer button.secondary { background-color: #008CBA; }
        .p2p-step button:hover, .screen button:hover, #toggleMuteBtnContainer button:hover { opacity:0.9; }
        .p2p-step button:disabled, .screen button:disabled, #toggleMuteBtnContainer button:disabled { background-color: #555; cursor: not-allowed; }
        .p2p-step hr { border-color: #444; margin: 15px 0; }

        #gameContainer { display: none; }
        #gameWrapper { display: flex; justify-content: center; gap: 20px; align-items: flex-start; max-width: 1100px; margin: 0 auto; flex-wrap: wrap; padding: 0 10px; }
        #gameControls { background-color: #1a1a1a; padding: 15px; border-radius: 8px; width: 280px; display: flex; flex-direction: column; gap: 15px; border: 1px solid #333; color: #ccc; }
        .player-controls { background-color: #2a2a2a; padding: 12px; border-radius: 8px; }
        .type-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        .type-button { font-size: 1.1rem; padding: 10px 16px; cursor: pointer; border: 2px solid #555; border-radius: 8px; background-color: #2a2a2a; color: #ddd; user-select: none; width: auto; min-width: 70px; }
        .type-button.selected { font-weight: bold; }
        #player1Controls .type-button.selected { border-color: #88ccff; color: #aaddff; }
        #player2Controls .type-button.selected { border-color: #ff6347; color: #ff9b90; }
        #gameCanvas { background-color: #1e1e1e; border: 1px solid #444; border-radius: 8px; cursor: crosshair; width: 100%; max-width: 700px; height: auto; }
        #actions button { width: 100%; margin-top:10px; box-sizing: border-box; }
        .menu-button { background-color: #555555; text-decoration:none; display:inline-block; padding: 12px 24px; text-align:center; color: white; border-radius: 5px; transition: background-color 0.3s; margin-top: 10px; }
        .menu-button:hover { opacity: 0.9; }
        .start-button { background-color: #3a8f3a; color: white; font-weight: bold; }
        .ice-status {font-size: 0.8em; color: #aaa; margin-top: -5px; margin-bottom: 5px; display: block;}
        #readinessCheck p { margin: 5px 0; font-size: 0.9em;}
        #toggleMuteBtnContainer { margin-top: 15px; padding-top:10px; border-top: 1px solid #444;}
        #p2pMessage { margin-top: 15px; padding: 10px; background-color: #333; border: 1px solid #555; border-radius: 5px; color: #eee; min-height: 20px;}


        @media (max-width: 768px) {
            body { padding: 10px; }
            .screen { padding: 15px; }
            #gameWrapper { flex-direction: column; align-items: center; padding: 0; }
            #gameControls { width: 100%; max-width: 400px; }
            #gameCanvas { width: 100% !important; max-width: 100%; }
            .p2p-step button, .screen button, #toggleMuteBtnContainer button, .menu-button { width: calc(100% - 20px); margin-left:10px; margin-right:10px; box-sizing:border-box; }
            .p2p-step button:first-of-type { margin-top: 10px; }
        }
    </style>
</head>
<body>
    <h1>Rock, Paper, Scissors: P2P</h1>

    <div id="roleSelectionScreen" class="screen">
        <h2>1. –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É —Ä–æ–ª—å:</h2>
        <button id="selectHostBtn" class="start-button">–°–æ–∑–¥–∞—Ç—å –ò–≥—Ä—É (–•–æ—Å—Ç)</button>
        <button id="selectClientBtn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ò–≥—Ä–µ (–ö–ª–∏–µ–Ω—Ç)</button>
        <a href="../index.html" class="menu-button">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</a>
    </div>

    <div id="p2pControlsScreen" class="screen" style="display:none;">
        <h3>P2P –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ (–®–∞–≥ –∑–∞ –®–∞–≥–æ–º)</h3>
        <p>–í–∞—à–∞ —Ä–æ–ª—å: <strong id="playerRoleDisplay">...</strong> | –°—Ç–∞—Ç—É—Å: <span id="connectionStatus">–û–∂–∏–¥–∞–Ω–∏–µ</span></p>
        <hr>

        <div id="p2pStep_Host_1_CreateOffer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í—ã - –•–æ—Å—Ç. –ù–∞–∂–º–∏—Ç–µ '–°–æ–∑–¥–∞—Ç—å –û—Ñ—Ñ–µ—Ä', —á—Ç–æ–±—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–µ SDP-–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.</p>
            <button id="host_createOfferBtn">–°–æ–∑–¥–∞—Ç—å –û—Ñ—Ñ–µ—Ä</button>
            <textarea id="host_localSdpOfferOutput" placeholder="–í–∞—à SDP-–û—Ñ—Ñ–µ—Ä –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="ice-status" id="host_iceStatus">–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...</p>
            <textarea id="host_localIceCandidatesOutput" placeholder="–í–∞—à–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="p2p-instruction" id="host_offerCreatedInstruction" style="display:none;">–û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω—ã. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∫–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ö–ª–∏–µ–Ω—Ç—É. –ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ '–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É'.</p>
            <button id="host_proceedToSetAnswerBtn" style="display:none;">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É</button>
        </div>

        <div id="p2pStep_Host_2_SetAnswer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction"><b>–ü—Ä–∏–µ–º –û—Ç–≤–µ—Ç–∞ –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞.</b> –í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞ –≤ –ø–µ—Ä–≤–æ–µ –ø–æ–ª–µ, –∞ –µ–≥–æ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –≤–æ –≤—Ç–æ—Ä–æ–µ. –ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –û—Ç–≤–µ—Ç –∏ –ö–∞–Ω–¥–∏–¥–∞—Ç—ã'.</p>
            <textarea id="host_remoteSdpAnswerInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞"></textarea>
            <textarea id="host_remoteIceCandidatesInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞"></textarea>
            <button id="host_setRemoteSdpAnswerBtn" class="secondary">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –û—Ç–≤–µ—Ç –∏ –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –ö–ª–∏–µ–Ω—Ç–∞</button>
        </div>

        <div id="p2pStep_Client_1_PasteOffer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í—ã - –ö–ª–∏–µ–Ω—Ç. –í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –æ—Ç –•–æ—Å—Ç–∞ –≤ –ø–µ—Ä–≤–æ–µ –ø–æ–ª–µ, –∞ –µ–≥–æ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –≤–æ –≤—Ç–æ—Ä–æ–µ. –ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–∏–Ω—è—Ç—å –û—Ñ—Ñ–µ—Ä –∏ –°–æ–∑–¥–∞—Ç—å –û—Ç–≤–µ—Ç'.</p>
            <textarea id="client_remoteSdpOfferInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –æ—Ç –•–æ—Å—Ç–∞"></textarea>
            <textarea id="client_remoteIceCandidatesInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –•–æ—Å—Ç–∞"></textarea>
            <button id="client_acceptOfferAndProceedToAnswerBtn">–ü—Ä–∏–Ω—è—Ç—å –û—Ñ—Ñ–µ—Ä –∏ –°–æ–∑–¥–∞—Ç—å –û—Ç–≤–µ—Ç</button>
        </div>
        
        <div id="p2pStep_Client_2_CreateAnswerAndSend" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í–∞—à SDP –û—Ç–≤–µ—Ç –ø–æ—è–≤–∏—Ç—Å—è –≤ –ø–µ—Ä–≤–æ–º –ø–æ–ª–µ, –∞ –≤–∞—à–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –≤–æ –≤—Ç–æ—Ä–æ–º. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∫–∞–∂–¥—ã–π –∏–∑ –Ω–∏—Ö –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –•–æ—Å—Ç—É.</p>
            <textarea id="client_localSdpAnswerOutput" placeholder="–í–∞—à SDP –û—Ç–≤–µ—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="ice-status" id="client_iceStatus">–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...</p>
            <textarea id="client_localIceCandidatesOutput" placeholder="–í–∞—à–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="p2p-instruction" id="client_answerCreatedInstruction" style="display:none;">–í–∞—à –û—Ç–≤–µ—Ç –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω—ã. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏—Ö –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –•–æ—Å—Ç—É.</p>
        </div>
        <div id="p2pMessage" style="display:none;"></div>

        <div id="toggleMuteBtnContainer" style="display:none;">
            <button id="toggleMuteBtn" class="secondary">–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
        </div>
        <button id="restartP2PConnectionBtn" class="secondary" style="margin-top: 20px; background-color:#c82333;">–ù–∞—á–∞—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <div id="gameContainer">
        <div id="gameWrapper">
            <div id="gameControls">
                <div class="player-controls" id="player1Controls" style="display:none;"> <h2>–ò–≥—Ä–æ–∫ 1 (—Å–∏–Ω–∏–π)</h2>
                    <div class="type-buttons">
                        <button data-type="rock" class="type-button selected">ü™®</button>
                        <button data-type="paper" class="type-button">üìÑ</button>
                        <button data-type="scissors" class="type-button">‚úÇÔ∏è </button>
                    </div>
                    <p>–Æ–Ω–∏—Ç—ã: <span id="player1UnitsCount">0</span></p>
                </div>

                <div class="player-controls" id="player2Controls" style="display:none;"> <h2>–ò–≥—Ä–æ–∫ 2 (–∫—Ä–∞—Å–Ω—ã–π)</h2>
                    <div class="type-buttons">
                        <button data-type="rock" class="type-button selected">ü™®</button>
                        <button data-type="paper" class="type-button">üìÑ</button>
                        <button data-type="scissors" class="type-button">‚úÇÔ∏è </button>
                    </div>
                    <p>–Æ–Ω–∏—Ç—ã: <span id="player2UnitsCount">0</span></p>
                </div>

                <div id="actions">
                    <p>–í—ã –∏–≥—Ä–∞–µ—Ç–µ –∑–∞: <strong id="activePlayerDisplayInGame">–û–∂–∏–¥–∞–Ω–∏–µ</strong></p>
                    <div id="readinessCheck" style="display:none;">
                        <p>–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å: –í—ã (<span id="localReadyStatus">–ù–µ –≥–æ—Ç–æ–≤—ã</span>), –û–ø–ø–æ–Ω–µ–Ω—Ç (<span id="remoteReadyStatus">–ù–µ –≥–æ—Ç–æ–≤</span>)</p>
                    </div>
                    <button id="playerReadyBtn" class="start-button" style="display:none;">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</button>
                    <button id="restartGameBtn" class="start-button" style="display:none;">–ò–≥—Ä–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
                    <a href="#" id="mainMenuBtnFromGame" class="menu-button">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (–ù–æ–≤–æ–µ P2P)</a>
                </div>
            </div>
            <canvas id="gameCanvas" width="700" height="500"></canvas>
        </div>
    </div>
    <audio id="remoteAudio" autoplay style="display:none;"></audio>

    <script>
const Game = {
            WIDTH: 700, HEIGHT: 500, TYPES: ["rock", "paper", "scissors"], EMOJIS: { rock: "ü™®", paper: "üìÑ", scissors: "‚úÇÔ∏è" }, COLORS: { player1: "#87CEFA", player2: "#FF6347" },
            units: [],
            targetUnitsState: [], // –ù–æ–≤–æ–µ: –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–ª–µ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π, –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –æ—Ç —Ö–æ—Å—Ç–∞
            interpolationFactor: 0.2, // –ù–æ–≤–æ–µ: –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ (–Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ –∂–µ–ª–∞–Ω–∏—é)
            placing: true, selectedTypes: { player1: "rock", player2: "rock" }, loop: null, winnerText: "", winnerPlayer: null, isRunning: false,
            isHost: false, peerConnection: null, dataChannel: null,
            localPlayerReady: false, remotePlayerReady: false,
            localStream: null, // For voice chat
            lastStateBroadcastTime: 0,
            stateBroadcastInterval: 100 // Milliseconds between state broadcasts
        };
        // Game class Unit, helper functions (wrapDistance, shouldChase, etc.), Game.update, Game.checkWinCondition, Game.showWinner (mostly unchanged)
        (function(ns){
            class Unit {
                constructor(x, y, type, player, id = null) {
                    this.id = id || Math.random().toString(36).substr(2, 9);
                    this.x = x; this.y = y;
                    this.targetX = x; // –ù–æ–≤–æ–µ: —Ü–µ–ª–µ–≤–∞—è X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
                    this.targetY = y; // –ù–æ–≤–æ–µ: —Ü–µ–ª–µ–≤–∞—è Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
                    this.type = type; this.player = player;
                    this.vx = Math.random() * 2 - 1; this.vy = Math.random() * 2 - 1;
                    this.radius = 12; this.spawnTime = Date.now(); this.nextDashTime = Date.now() + this.getRandomDashInterval();
                }
                getRandomDashInterval() { return 2000 + Math.random() * 3000; }
                dash() { const d = 5 + Math.random()*10, s = Math.hypot(this.vx,this.vy)||1; this.vx += (this.vx/s)*d; this.vy += (this.vy/s)*d; this.nextDashTime = Date.now() + this.getRandomDashInterval(); }
                move() {
                    if (Date.now() >= this.nextDashTime) this.dash();
                    let target = null, minDist = Infinity;
                    for (const other of ns.units) {
                        if (other === this || other.player === this.player) continue;
                        if (shouldChase(this.type, other.type) || shouldFlee(this.type, other.type)) {
                            const dx = wrapDistance(this.x, other.x, ns.WIDTH), dy = wrapDistance(this.y, other.y, ns.HEIGHT), dist = Math.hypot(dx, dy);
                            if (dist < minDist) { minDist = dist; target = other; }
                        }
                    }
                    const baseSpeed = 1.5;
                    if (target) {
                        const dx = wrapDistance(this.x, target.x, ns.WIDTH), dy = wrapDistance(this.y, target.y, ns.HEIGHT), d = Math.hypot(dx, dy) + 0.01;
                        if (shouldChase(this.type, target.type)) { this.vx += (dx/d)*baseSpeed*0.1; this.vy += (dy/d)*baseSpeed*0.1; }
                        else if (shouldFlee(this.type, target.type)) { this.vx -= (dx/d)*baseSpeed*0.1; this.vy -= (dy/d)*baseSpeed*0.1; }
                    }
                    for (const other of ns.units) {
                        if (other === this || other.player !== this.player) continue;
                        const dx = wrapDistance(this.x, other.x, ns.WIDTH), dy = wrapDistance(this.y, other.y, ns.HEIGHT), dist = Math.hypot(dx, dy);
                        if (dist > 0 && dist < this.radius * 2) { const r = 1.5; this.vx -= (dx/dist)*r*0.05; this.vy -= (dy/dist)*r*0.05; }
                    }
                    this.vx *= 0.95; this.vy *= 0.95;
                    this.x = (this.x + this.vx + ns.WIDTH)%ns.WIDTH; this.y = (this.y + this.vy + ns.HEIGHT)%ns.HEIGHT;
                }
                draw(ctx) {
                    ctx.save(); ctx.translate(this.x, this.y); const age = Date.now() - this.spawnTime;
                    if (age < 1000) ctx.globalAlpha = 0.5 + 0.5 * (age / 1000);
                    ctx.font = "20px serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.shadowColor = ns.COLORS[this.player]; ctx.shadowBlur = 6; ctx.fillStyle = ns.COLORS[this.player];
                    ctx.fillText(ns.EMOJIS[this.type],0,0); ctx.restore();
                }
            }
            ns.Unit = Unit;
            function wrapDistance(a,b,size){let d=b-a; if(Math.abs(d)>size/2)d-=Math.sign(d)*size; return d;}
            function shouldChase(t1,t2){const m={rock:"scissors",scissors:"paper",paper:"rock"}; return m[t1]===t2;}
            function shouldFlee(t1,t2){const m={rock:"paper",paper:"scissors",scissors:"rock"}; return m[t1]===t2;}
            function beats(t1,t2){return shouldChase(t1,t2);}
            function resolveConflict(a,b){
                let changed=false;
                if(beats(a.type,b.type)){b.type=a.type;b.player=a.player;changed=true;}
                else if(beats(b.type,a.type)){a.type=b.type;a.player=b.player;changed=true;}
            }
            ns.update = function(){
                // Only host runs game logic (movement, collisions etc.)
                if (!ns.isHost) return;

                if (ns.isRunning) { // Movement and collisions only if running
                    for(let u of ns.units) u.move();
                    for (let i=0; i<ns.units.length; i++){
                        for (let j=i+1; j<ns.units.length; j++){
                            const a=ns.units[i], b=ns.units[j];
                            if(a.player === b.player) continue;
                            const dx = wrapDistance(a.x,b.x,ns.WIDTH), dy = wrapDistance(a.y,b.y,ns.HEIGHT), dist = Math.hypot(dx,dy);
                            if(dist < 24 && a.type !== b.type){
                                resolveConflict(a,b);
                                const overlap=24-dist,nx=dx/dist,ny=dy/dist;
                                a.x-=nx*overlap*0.5;a.y-=ny*overlap*0.5;b.x+=nx*overlap*0.5;b.y+=ny*overlap*0.5;
                            }
                        }
                    }
                }
                
                checkWinCondition();

                // Broadcast state if host and game is running OR placing
                if (ns.isHost && (ns.isRunning || ns.placing) && Date.now() - ns.lastStateBroadcastTime > ns.stateBroadcastInterval) {
                    sendMessageP2P("game_state_update", {
                        units: ns.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })), // Send serializable data
                        winnerText: ns.winnerText,
                        winnerPlayer: ns.winnerPlayer,
                        isRunning: ns.isRunning,
                        placing: ns.placing
                    });
                    ns.lastStateBroadcastTime = Date.now();
                }
            };
            function checkWinCondition(){
                if(ns.placing)return;
                const p1U=ns.units.filter(u=>u.player==="player1"), p2U=ns.units.filter(u=>u.player==="player2");
                let gameEnded = false; // –§–ª–∞–≥, —á—Ç–æ–±—ã –∑–Ω–∞—Ç—å, –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å –ª–∏ –∏–≥—Ä–∞
                if(ns.units.length===0 && !ns.placing){showWinner("–ù–∏—á—å—è! (–ù–µ—Ç —é–Ω–∏—Ç–æ–≤)",null); gameEnded = true;}
                else if(p1U.length===0 && ns.units.length>0){showWinner("–ò–≥—Ä–æ–∫ 2 –ø–æ–±–µ–¥–∏–ª!","player2"); gameEnded = true;}
                else if(p2U.length===0 && ns.units.length>0){showWinner("–ò–≥—Ä–æ–∫ 1 –ø–æ–±–µ–¥–∏–ª!","player1"); gameEnded = true;}
                else {
                    const p1CB=p1U.some(u1=>p2U.some(u2=>shouldChase(u1.type,u2.type))), p2CB=p2U.some(u2=>p1U.some(u1=>shouldChase(u2.type,u1.type)));
                    if(!p1CB && !p2CB && ns.units.length>0){
                        if(p1U.length>p2U.length)showWinner("–ò–≥—Ä–æ–∫ 1 –ø–æ–±–µ–¥–∏–ª!","player1");
                        else if(p2U.length>p1U.length)showWinner("–ò–≥—Ä–æ–∫ 2 –ø–æ–±–µ–¥–∏–ª!","player2");
                        else showWinner("–ù–∏—á—å—è!",null);
                        gameEnded = true;
                    }
                }

                if (gameEnded && ns.isHost) {
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å
                    sendMessageP2P("game_state_update", {
                        units: ns.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        winnerText: ns.winnerText,
                        winnerPlayer: ns.winnerPlayer,
                        isRunning: ns.isRunning, // –≠—Ç–æ –±—É–¥–µ—Ç false –ø–æ—Å–ª–µ showWinner
                        placing: ns.placing
                    });
                }
            }
            function showWinner(text,player){
                ns.winnerText=text; ns.winnerPlayer=player; ns.isRunning=false;
                if(document.getElementById("restartGameBtn"))document.getElementById("restartGameBtn").style.display="block";
                if(document.getElementById("playerReadyBtn"))document.getElementById("playerReadyBtn").style.display="none";
                if(document.getElementById("readinessCheck"))document.getElementById("readinessCheck").style.display="none";
                document.querySelectorAll(".type-buttons").forEach(c=>c.style.pointerEvents="none");
            }
        })(Game);
        
        (function(ns) { // ui.js
            const p1CtrlElement = document.getElementById("player1Controls");
            const p2CtrlElement = document.getElementById("player2Controls");
            const activePlayerDispGame = document.getElementById("activePlayerDisplayInGame");
            const p1UnitsSpan = document.getElementById("player1UnitsCount");
            const p2UnitsSpan = document.getElementById("player2UnitsCount");

            function updatePlayerButtons(container, player) {
                container.querySelectorAll(".type-button").forEach(btn => {
                    btn.classList.toggle("selected", ns.selectedTypes[player] === btn.getAttribute("data-type"));
                });
            }
            ns.ui = {
                updateUI: function() {
                    if (ns.isHost) {
                        activePlayerDispGame.textContent = "–ò–≥—Ä–æ–∫ 1 (–í—ã - —Å–∏–Ω–∏–π)";
                        p1CtrlElement.style.display = "block";
                        p1CtrlElement.style.pointerEvents = (ns.placing || !ns.isRunning) ? "auto" : "none";
                        p2CtrlElement.style.display = "none"; // Host doesn't need P2 controls
                        updatePlayerButtons(p1CtrlElement, "player1");
                    } else { // Client
                        activePlayerDispGame.textContent = "–ò–≥—Ä–æ–∫ 2 (–í—ã - –∫—Ä–∞—Å–Ω—ã–π)";
                        p1CtrlElement.style.display = "none"; // Client doesn't need P1 controls
                        p2CtrlElement.style.display = "block";
                        p2CtrlElement.style.pointerEvents = (ns.placing || !ns.isRunning) ? "auto" : "none";
                        updatePlayerButtons(p2CtrlElement, "player2");
                    }
                                        
                    p1UnitsSpan.textContent = ns.units.filter(u=>u.player==="player1").length;
                    p2UnitsSpan.textContent = ns.units.filter(u=>u.player==="player2").length;
                },
                setupTypeButtons: function() {
                    [...p1CtrlElement.querySelectorAll(".type-button"), ...p2CtrlElement.querySelectorAll(".type-button")].forEach(btn => {
                        const handler = () => {
                            const player = btn.closest(".player-controls").id === "player1Controls" ? "player1" : "player2";
                            // Only allow local player to change their selected type
                            if ((ns.isHost && player === "player1") || (!ns.isHost && player === "player2")) {
                                ns.selectedTypes[player] = btn.getAttribute("data-type");
                                // Send selected type to opponent (Host will handle player2's type, Client will send its own)
                                if (ns.isHost && player === "player1") { // If host changes its own type, inform client
                                    sendMessageP2P("selected_type", { player: "player1", type: ns.selectedTypes.player1 });
                                } else if (!ns.isHost && player === "player2") { // If client changes its own type, inform host
                                    sendMessageP2P("selected_type", { player: "player2", type: ns.selectedTypes.player2 });
                                }
                            } else return; // Prevent changing opponent's type locally
                            ns.ui.updateUI();
                        };
                        btn.addEventListener("click", handler);
                        btn.addEventListener("touchstart", e=>{ e.preventDefault(); handler(); }, {passive:false});
                    });
                }
            };
        })(Game);

        let sendMessageP2P;
        document.addEventListener("DOMContentLoaded", function () {
            const rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }] };
            const roleScreen = document.getElementById("roleSelectionScreen");
            const p2pScreen = document.getElementById("p2pControlsScreen");
            const gameScreen = document.getElementById("gameContainer");

            const playerRoleDisp = document.getElementById("playerRoleDisplay");
            const connectionStatusSpan = document.getElementById("connectionStatus");
            const p2pMessageDiv = document.getElementById("p2pMessage"); // New element for messages

            const hostStep1 = document.getElementById("p2pStep_Host_1_CreateOffer");
            const hostStep2 = document.getElementById("p2pStep_Host_2_SetAnswer");
            const clientStep1 = document.getElementById("p2pStep_Client_1_PasteOffer");
            const clientStep2 = document.getElementById("p2pStep_Client_2_CreateAnswerAndSend");

            const host_createOfferBtn = document.getElementById("host_createOfferBtn");
            const host_localSdpOfferOutput = document.getElementById("host_localSdpOfferOutput");
            const host_localIceCandidatesOutput = document.getElementById("host_localIceCandidatesOutput"); // New
            const host_iceStatus = document.getElementById("host_iceStatus"); // New
            const host_offerCreatedInstruction = document.getElementById("host_offerCreatedInstruction");
            const host_proceedToSetAnswerBtn = document.getElementById("host_proceedToSetAnswerBtn");
            const host_remoteSdpAnswerInput = document.getElementById("host_remoteSdpAnswerInput");
            const host_remoteIceCandidatesInput = document.getElementById("host_remoteIceCandidatesInput"); // New
            const host_setRemoteSdpAnswerBtn = document.getElementById("host_setRemoteSdpAnswerBtn");

            const client_remoteSdpOfferInput = document.getElementById("client_remoteSdpOfferInput");
            const client_remoteIceCandidatesInput = document.getElementById("client_remoteIceCandidatesInput"); // New
            const client_acceptOfferAndProceedToAnswerBtn = document.getElementById("client_acceptOfferAndProceedToAnswerBtn");
            const client_localSdpAnswerOutput = document.getElementById("client_localSdpAnswerOutput");
            const client_localIceCandidatesOutput = document.getElementById("client_localIceCandidatesOutput"); // New
            const client_iceStatus = document.getElementById("client_iceStatus"); // New
            const client_answerCreatedInstruction = document.getElementById("client_answerCreatedInstruction");
            
            const restartP2PBtn = document.getElementById("restartP2PConnectionBtn");
            const mainMenuFromGameBtn = document.getElementById("mainMenuBtnFromGame");
            const toggleMuteBtnContainer = document.getElementById("toggleMuteBtnContainer");
            const toggleMuteBtn = document.getElementById("toggleMuteBtn");
            const remoteAudioElement = document.getElementById("remoteAudio");


            const playerReadyBtn = document.getElementById("playerReadyBtn");
            const restartGameBtn = document.getElementById("restartGameBtn");
            const readinessCheckDiv = document.getElementById("readinessCheck");
            const localReadyStatusSpan = document.getElementById("localReadyStatus");
            const remoteReadyStatusSpan = document.getElementById("remoteReadyStatus");
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            function updateP2PStatus(statusText) { connectionStatusSpan.textContent = statusText; }
            function showP2PMessage(message, isError = false) {
                p2pMessageDiv.textContent = message;
                p2pMessageDiv.style.display = 'block';
                p2pMessageDiv.style.backgroundColor = isError ? '#882222' : '#333';
                p2pMessageDiv.style.borderColor = isError ? '#FF0000' : '#555';
            }
            function clearP2PMessage() {
                p2pMessageDiv.textContent = '';
                p2pMessageDiv.style.display = 'none';
            }

            function showP2PStep(stepIdToShow) {
                [hostStep1, hostStep2, clientStep1, clientStep2].forEach(s => s.style.display = 'none');
                if (document.getElementById(stepIdToShow)) document.getElementById(stepIdToShow).style.display = 'block';
                clearP2PMessage(); // Clear message when changing steps
            }
            function resetP2PStateAndUI(showMessage = true, message = "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–±—Ä–æ—à–µ–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.") {
                console.log("Resetting P2P state and UI...");
                if (showMessage && !resetP2PStateAndUI.isResetting) {
                    resetP2PStateAndUI.isResetting = true; 
                    showP2PMessage(message, true); // Show error message
                    resetP2PStateAndUI.isResetting = false;
                }
                if (Game.peerConnection) { 
                    console.log("Closing existing PeerConnection.");
                    Game.peerConnection.close(); 
                    Game.peerConnection = null; 
                }
                if (Game.dataChannel) { 
                    console.log("Closing existing DataChannel.");
                    Game.dataChannel.close(); 
                    Game.dataChannel = null; 
                }
                if (Game.localStream) { 
                    console.log("Stopping local media tracks.");
                    Game.localStream.getTracks().forEach(track => track.stop()); 
                    Game.localStream = null; 
                    toggleMuteBtnContainer.style.display = 'none';
                }

                Game.isHost = false;
                Game.localPlayerReady = false; 
                Game.remotePlayerReady = false;
                
                [host_localSdpOfferOutput, host_localIceCandidatesOutput, host_remoteSdpAnswerInput, host_remoteIceCandidatesInput,
                 client_remoteSdpOfferInput, client_remoteIceCandidatesInput, client_localSdpAnswerOutput, client_localIceCandidatesOutput]
                 .forEach(ta => { if(ta) ta.value = ""; });
                
                [
                    host_offerCreatedInstruction, host_proceedToSetAnswerBtn,
                    client_answerCreatedInstruction
                ]
                 .forEach(el => { if(el) el.style.display = "none"; });

                // Reset ICE status indicators
                if (host_iceStatus) host_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";
                if (client_iceStatus) client_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";


                roleScreen.style.display = 'block'; 
                p2pScreen.style.display = 'none'; 
                gameScreen.style.display = 'none';
                updateP2PStatus("–û—Ç–∫–ª—é—á–µ–Ω–æ");
                console.log("P2P state reset complete.");
            }
            resetP2PStateAndUI.isResetting = false;

            restartP2PBtn.addEventListener("click", () => resetP2PStateAndUI(false));
            mainMenuFromGameBtn.addEventListener("click", (e) => {
                e.preventDefault();
                resetP2PStateAndUI(false);
                Game.units = []; Game.targetUnitsState = []; Game.winnerText = ""; Game.isRunning = false; if(Game.loop) cancelAnimationFrame(Game.loop); Game.draw();
            });

            let isMuted = false;
            toggleMuteBtn.addEventListener('click', () => {
                if (Game.localStream) {
                    Game.localStream.getAudioTracks().forEach(track => {
                        track.enabled = !track.enabled;
                    });
                    isMuted = !Game.localStream.getAudioTracks()[0]?.enabled;
                    toggleMuteBtn.textContent = isMuted ? "–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω" : "–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω";
                    console.log(`Microphone is now ${isMuted ? 'muted' : 'unmuted'}.`);
                }
            });


            sendMessageP2P = function(type, payload) {
                if (Game.dataChannel && Game.dataChannel.readyState === "open") {
                    try {
                        Game.dataChannel.send(JSON.stringify({ type, payload }));
                        console.log("Sent P2P message:", type, payload);
                    } catch (e) {
                        console.error("Error sending P2P message:", e);
                    }
                } else {
                    console.warn("DataChannel not open for P2P message:", type);
                }
            }

            async function initPeerConnection() {
                console.log("Initializing PeerConnection...");
                if (Game.peerConnection) { Game.peerConnection.close(); } // Ensure a clean slate
                Game.peerConnection = new RTCPeerConnection(rtcConfig);

                if (Game.localStream) {
                    Game.localStream.getTracks().forEach(track => {
                        Game.peerConnection.addTrack(track, Game.localStream);
                    });
                    console.log("Added local audio track to PeerConnection.");
                }

                Game.peerConnection.ontrack = event => {
                    console.log("Remote track received:", event.track, event.streams);
                    if (remoteAudioElement && event.streams && event.streams[0]) {
                        if (remoteAudioElement.srcObject !== event.streams[0]) {
                             remoteAudioElement.srcObject = event.streams[0];
                             console.log("Remote audio stream assigned.");
                        }
                    }
                };

                Game.peerConnection.onconnectionstatechange = () => {
                    const state = Game.peerConnection.connectionState;
                    updateP2PStatus(state);
                    console.log("PeerConnection state changed:", state);
                    if (state === "failed" || state === "disconnected" || state === "closed") {
                         if (!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true, `P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ ${state}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.`);
                    }
                };

                // Host creates data channel
                if (Game.isHost) {
                    Game.dataChannel = Game.peerConnection.createDataChannel("gameChannel");
                    console.log("DataChannel created by Host.");
                    setupDataChannelEvents(Game.dataChannel);
                } else { // Client receives data channel
                    Game.peerConnection.ondatachannel = event => {
                        Game.dataChannel = event.channel;
                        console.log("DataChannel received by Client.");
                        setupDataChannelEvents(Game.dataChannel);
                    };
                }
                console.log("PeerConnection initialized.");
            }
            
            function setupDataChannelEvents(channel) {
                channel.onopen = () => {
                    updateP2PStatus("P2P –ö–∞–Ω–∞–ª –û—Ç–∫—Ä—ã—Ç - –°–æ–µ–¥–∏–Ω–µ–Ω–æ!");
                    p2pScreen.style.display = 'none'; gameScreen.style.display = 'block';
                    Game.placing = true; Game.localPlayerReady = false; Game.remotePlayerReady = false;
                    readinessCheckDiv.style.display = 'block';
                    localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã'; remoteReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤';
                    playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ"; playerReadyBtn.style.display = 'inline-block';
                    Game.units = []; // –û—á–∏—â–∞–µ–º —é–Ω–∏—Ç—ã –ø—Ä–∏ –Ω–æ–≤–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
                    Game.targetUnitsState = []; // –û—á–∏—â–∞–µ–º —Ü–µ–ª–µ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                    Game.ui.updateUI(); Game.draw(); // Initial draw with current units
                    clearP2PMessage(); // Clear any messages
                    console.log("DataChannel opened.");
                };
                channel.onmessage = event => {
                    try { 
                        const msg = JSON.parse(event.data); 
                        console.log("Received P2P message:", msg.type, msg.payload);
                        handleP2PMessage(msg.type, msg.payload); 
                    }
                    catch (e) { console.error("Error parsing P2P message:", e, event.data); }
                };
                channel.onclose = () => { 
                    console.log("DataChannel closed.");
                    if(!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,"P2P –ö–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫—Ä—ã—Ç.") 
                };
                channel.onerror = error => { 
                    console.error("DataChannel error:", error);
                    if(!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,`–û—à–∏–±–∫–∞ P2P –ö–∞–Ω–∞–ª–∞ –¥–∞–Ω–Ω—ã—Ö: ${error.message || error}`) 
                };
            }
            
            // Make handleP2PMessage async because it uses await
            async function handleP2PMessage(type, payload) {
                switch (type) {
                    case "player_readiness":
                        Game.remotePlayerReady = payload.ready;
                        remoteReadyStatusSpan.textContent = Game.remotePlayerReady ? '–ì–æ—Ç–æ–≤' : '–ù–µ –≥–æ—Ç–æ–≤';
                        if (Game.isHost) checkStartConditions();
                        break;
                    case "selected_type":
                        if (payload.player === "player1") Game.selectedTypes.player1 = payload.type;
                        if (payload.player === "player2") Game.selectedTypes.player2 = payload.type;
                        Game.ui.updateUI(); // Update UI for changes in selected types
                        break;
                    case "request_restart_game": // Client requests host to restart game
                        if (Game.isHost) {
                            restartGameLogic(); // Host restarts
                        }
                        break;
                    case "start_game": // Host tells client to start game
                        if (!Game.isHost) { // Only client needs to react to this
                            startGameLogic();
                        }
                        break;
                    case "unit_placement_request": // Client requests unit placement/removal
                        if (Game.isHost) {
                            const { x, y, unitIdToRemove, player, unitId } = payload; 
                            if (unitIdToRemove) { 
                                Game.units = Game.units.filter(u => u.id !== unitIdToRemove);
                            } else { 
                                const type = Game.selectedTypes[player];
                                const newU = new Game.Unit(x, y, type, player, unitId); 
                                Game.units.push(newU);
                            }
                            Game.ui.updateUI(); 
                            Game.draw(); 
                            Game.targetUnitsState = Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player }));
                            sendMessageP2P("game_state_update", { 
                                units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })), 
                                winnerText: Game.winnerText,
                                winnerPlayer: Game.winnerPlayer,
                                isRunning: Game.isRunning,
                                placing: Game.placing
                            });
                        }
                        break;
                    case "game_state_update": // Client receives state update from Host
                        if (!Game.isHost) {
                            Game.targetUnitsState = payload.units; 
                            Game.winnerText = payload.winnerText;
                            Game.winnerPlayer = payload.winnerPlayer;
                            Game.isRunning = payload.isRunning;
                            Game.placing = payload.placing;

                            if (payload.gameReset) {
                                Game.localPlayerReady = false;
                                Game.remotePlayerReady = false; 
                                localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã';
                                remoteReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤'; 
                                playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ";
                                playerReadyBtn.style.display = 'inline-block';
                                readinessCheckDiv.style.display = 'block';
                            }

                            if ((Game.isRunning || Game.placing) && !Game.loop) {
                                Game.loop = requestAnimationFrame(Game.gameLoop);
                            } else if (!Game.isRunning && Game.loop && Game.winnerText) {
                                cancelAnimationFrame(Game.loop);
                                Game.loop = null;
                            }

                            Game.ui.updateUI();
                            Game.draw(); 

                            if (!Game.isRunning && Game.winnerText) {
                                document.getElementById("restartGameBtn").style.display = "block";
                                document.getElementById("playerReadyBtn").style.display = "none";
                                document.getElementById("readinessCheck").style.display = "none";
                                document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "none");
                            } else if (Game.placing) {
                                document.getElementById("restartGameBtn").style.display = "none";
                                document.getElementById("playerReadyBtn").style.display = "inline-block";
                                document.getElementById("readinessCheck").style.display = "block";
                                document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "auto"); 
                            }
                        }
                        break;
                    // --- NEW P2P SIGNALING MESSAGES (FOR MANUAL COPY/PASTE) ---
                    // These cases are now mainly informational as SDP and ICE are manually exchanged.
                    // The actual setting of remote SDP and adding ICE candidates happens when the user
                    // clicks "–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –û—Ç–≤–µ—Ç –∏ –ö–∞–Ω–¥–∏–¥–∞—Ç—ã –ö–ª–∏–µ–Ω—Ç–∞" or "–ü—Ä–∏–Ω—è—Ç—å –û—Ñ—Ñ–µ—Ä –∏ –°–æ–∑–¥–∞—Ç—å –û—Ç–≤–µ—Ç"
                    case "sdp_offer":
                        console.log("Client received SDP Offer. (Informational only for manual signaling)");
                        if (!Game.isHost) {
                            client_remoteSdpOfferInput.value = payload.sdp;
                        }
                        break;
                    case "sdp_answer":
                        console.log("Host received SDP Answer. (Informational only for manual signaling)");
                        if (Game.isHost) {
                            host_remoteSdpAnswerInput.value = payload.sdp;
                        }
                        break;
                    case "ice_candidate":
                        console.log("Received ICE Candidate. (Informational only for manual signaling, will be part of full paste)");
                        break;
                    default: console.warn("Unknown P2P message type:", type);
                }
            }

            async function initializeRole(isHostRole) {
                Game.isHost = isHostRole;
                playerRoleDisp.textContent = isHostRole ? "–•–æ—Å—Ç (–ò–≥—Ä–æ–∫ 1)" : "–ö–ª–∏–µ–Ω—Ç (–ò–≥—Ä–æ–∫ 2)";
                let roleTextSuffix = "";

                try {
                    Game.localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true }, video: false });
                    console.log("Microphone access granted.");
                    toggleMuteBtnContainer.style.display = 'block';
                    toggleMuteBtn.textContent = "–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω";
                    isMuted = false;
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    Game.localStream = null;
                    toggleMuteBtnContainer.style.display = 'none';
                    roleTextSuffix = " (–ë–µ–∑ –∑–≤—É–∫–∞)";
                }
                playerRoleDisp.textContent = (isHostRole ? "–•–æ—Å—Ç (–ò–≥—Ä–æ–∫ 1)" : "–ö–ª–∏–µ–Ω—Ç (–ò–≥—Ä–æ–∫ 2)") + roleTextSuffix;
                
                roleScreen.style.display = 'none'; p2pScreen.style.display = 'block';
                if (isHostRole) {
                    showP2PStep('p2pStep_Host_1_CreateOffer'); 
                    updateP2PStatus("–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ñ—Ñ–µ—Ä–∞");
                } else {
                    showP2PStep('p2pStep_Client_1_PasteOffer'); 
                    updateP2PStatus("–û–∂–∏–¥–∞–Ω–∏–µ –û—Ñ—Ñ–µ—Ä–∞ –æ—Ç –•–æ—Å—Ç–∞");
                }
            }

            document.getElementById("selectHostBtn").addEventListener("click", () => initializeRole(true));
            document.getElementById("selectClientBtn").addEventListener("click", () => initializeRole(false));
            
            let localIceCandidates = []; // For storing ICE candidates before display/sending

            // Host creates Offer and gathers ICE candidates
            host_createOfferBtn.addEventListener("click", async () => {
                console.log("Host: Create Offer button clicked.");
                host_createOfferBtn.disabled = true;
                host_localSdpOfferOutput.value = "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è SDP –æ—Ñ—Ñ–µ—Ä–∞...";
                host_localIceCandidatesOutput.value = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";
                host_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";
                localIceCandidates = []; // Clear previous candidates
                clearP2PMessage();

                await initPeerConnection();

                Game.peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        localIceCandidates.push(event.candidate.toJSON());
                        host_localIceCandidatesOutput.value = JSON.stringify(localIceCandidates, null, 2);
                        console.log("Host ICE candidate:", event.candidate);
                    } else {
                        host_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω.";
                        console.log("Host: ICE gathering complete.");
                    }
                };

                try {
                    const offer = await Game.peerConnection.createOffer();
                    await Game.peerConnection.setLocalDescription(offer);
                    host_localSdpOfferOutput.value = JSON.stringify(offer);
                    console.log("Host: SDP Offer created and set as local description.", offer);
                    
                    setTimeout(() => {
                        host_offerCreatedInstruction.style.display = 'block';
                        host_proceedToSetAnswerBtn.style.display = 'inline-block';
                        host_createOfferBtn.disabled = false;
                        updateP2PStatus("–û—Ñ—Ñ–µ—Ä –∏ ICE —Å–æ–∑–¥–∞–Ω—ã. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏—Ö –ö–ª–∏–µ–Ω—Ç—É.");
                        showP2PMessage("–í–∞—à SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω—ã. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏—Ö –∏–∑ –ø–æ–ª–µ–π –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ö–ª–∏–µ–Ω—Ç—É.", false);
                    }, 2000); // Wait 2 seconds for candidates to gather

                } catch (e) { 
                    console.error("Host: Error creating offer:", e);
                    resetP2PStateAndUI(true, `–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ñ—Ñ–µ—Ä–∞: ${e.message}`); 
                }
            });

            host_proceedToSetAnswerBtn.addEventListener("click", () => showP2PStep('p2pStep_Host_2_SetAnswer'));
            
            // Host sets Remote SDP Answer and adds ICE candidates
            host_setRemoteSdpAnswerBtn.addEventListener("click", async () => {
                console.log("Host: Set Remote SDP Answer button clicked.");
                clearP2PMessage();
                if (!Game.peerConnection) { showP2PMessage("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ!", true); return; }
                if (!host_remoteSdpAnswerInput.value) { showP2PMessage("–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞!", true); return; }
                if (!host_remoteIceCandidatesInput.value) { showP2PMessage("–í—Å—Ç–∞–≤—å—Ç–µ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞!", true); return; }

                try {
                    const answerSdp = JSON.parse(host_remoteSdpAnswerInput.value);
                    const answer = new RTCSessionDescription(answerSdp);
                    await Game.peerConnection.setRemoteDescription(answer);
                    console.log("Host: Remote SDP Answer set.", answer);

                    const iceCandidates = JSON.parse(host_remoteIceCandidatesInput.value);
                    for (const candidate of iceCandidates) {
                        if (candidate) {
                            try {
                                await Game.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                console.log("Host: Added remote ICE candidate:", candidate);
                            } catch (e) {
                                console.warn("Host: Error adding remote ICE candidate:", e, candidate);
                            }
                        }
                    }
                    updateP2PStatus("SDP –û—Ç–≤–µ—Ç –ö–ª–∏–µ–Ω—Ç–∞ –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è.");
                    showP2PMessage("SDP –û—Ç–≤–µ—Ç –ö–ª–∏–µ–Ω—Ç–∞ –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è. –û–∂–∏–¥–∞–π—Ç–µ —Å—Ç–∞—Ç—É—Å–∞ '–°–æ–µ–¥–∏–Ω–µ–Ω–æ!'", false);
                } catch (e) { 
                    console.error("Host: Error setting remote SDP Answer or ICE candidates:", e);
                    showP2PMessage(`–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SDP –û—Ç–≤–µ—Ç–∞ –∏–ª–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤: ${e.message}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ—Ä–º–∞—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.`, true); 
                }
            });

            // Client accepts Offer and creates Answer
            client_acceptOfferAndProceedToAnswerBtn.addEventListener("click", async () => {
                console.log("Client: Accept Offer button clicked.");
                client_acceptOfferAndProceedToAnswerBtn.disabled = true;
                client_localSdpAnswerOutput.value = "–ì–µ–Ω–µ—Ä–∞—Ü–∏—è SDP –æ—Ç–≤–µ—Ç–∞...";
                client_localIceCandidatesOutput.value = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";
                client_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤...";
                localIceCandidates = []; // Clear previous candidates
                clearP2PMessage();


                if (!client_remoteSdpOfferInput.value) { showP2PMessage("–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –æ—Ç –•–æ—Å—Ç–∞!", true); client_acceptOfferAndProceedToAnswerBtn.disabled = false; return; }
                if (!client_remoteIceCandidatesInput.value) { showP2PMessage("–í—Å—Ç–∞–≤—å—Ç–µ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –•–æ—Å—Ç–∞!", true); client_acceptOfferAndProceedToAnswerBtn.disabled = false; return; }

                await initPeerConnection();

                Game.peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        localIceCandidates.push(event.candidate.toJSON());
                        client_localIceCandidatesOutput.value = JSON.stringify(localIceCandidates, null, 2);
                        console.log("Client ICE candidate:", event.candidate);
                    } else {
                        client_iceStatus.textContent = "–°–±–æ—Ä ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω.";
                        console.log("Client: ICE gathering complete.");
                    }
                };

                try {
                    const offerSdp = JSON.parse(client_remoteSdpOfferInput.value);
                    const offer = new RTCSessionDescription(offerSdp);
                    await Game.peerConnection.setRemoteDescription(offer);
                    console.log("Client: Remote SDP Offer set.", offer);
                    
                    // Add Host's ICE candidates
                    const remoteIceCandidates = JSON.parse(client_remoteIceCandidatesInput.value);
                    for (const candidate of remoteIceCandidates) {
                        if (candidate) {
                            try {
                                await Game.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                                console.log("Client: Added remote ICE candidate:", candidate);
                            } catch (e) {
                                console.warn("Client: Error adding remote ICE candidate:", e, candidate);
                            }
                        }
                    }
                    
                    const answer = await Game.peerConnection.createAnswer();
                    await Game.peerConnection.setLocalDescription(answer);
                    client_localSdpAnswerOutput.value = JSON.stringify(answer);
                    console.log("Client: SDP Answer created and set as local description.", answer);

                    setTimeout(() => {
                        client_answerCreatedInstruction.style.display = 'block';
                        showP2PStep('p2pStep_Client_2_CreateAnswerAndSend');
                        client_acceptOfferAndProceedToAnswerBtn.disabled = false;
                        updateP2PStatus("–û—Ñ—Ñ–µ—Ä –•–æ—Å—Ç–∞ –ø—Ä–∏–Ω—è—Ç. –í–∞—à –û—Ç–≤–µ—Ç –∏ ICE —Å–æ–∑–¥–∞–Ω—ã. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏—Ö –•–æ—Å—Ç—É.");
                        showP2PMessage("–í–∞—à SDP –û—Ç–≤–µ—Ç –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω—ã. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏—Ö –∏–∑ –ø–æ–ª–µ–π –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –•–æ—Å—Ç—É.", false);
                    }, 2000); // Wait 2 seconds for candidates to gather

                } catch (e) { 
                    console.error("Client: Error accepting offer or creating answer:", e);
                    showP2PMessage(`–û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è –û—Ñ—Ñ–µ—Ä–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ç–≤–µ—Ç–∞: ${e.message}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ—Ä–º–∞—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.`, true);
                }
            });


            playerReadyBtn.addEventListener("click", () => {
                Game.localPlayerReady = !Game.localPlayerReady;
                localReadyStatusSpan.textContent = Game.localPlayerReady ? '–ì–æ—Ç–æ–≤' : '–ù–µ –≥–æ—Ç–æ–≤—ã';
                playerReadyBtn.textContent = Game.localPlayerReady ? "–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞..." : "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ";
                sendMessageP2P("player_readiness", { ready: Game.localPlayerReady });
                if (Game.isHost) checkStartConditions();
            });

            function checkStartConditions() {
                if (Game.isHost && Game.localPlayerReady && Game.remotePlayerReady) {
                    startGameLogic();
                    sendMessageP2P("start_game", {
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        placing: Game.placing,
                        isRunning: Game.isRunning,
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer
                    });
                }
            }

            function startGameLogic() {
                if(Game.isRunning)return; 
                Game.placing=false; 
                Game.isRunning=true;
                readinessCheckDiv.style.display='none'; 
                playerReadyBtn.style.display='none';
                document.querySelectorAll(".type-buttons").forEach(b=>b.style.pointerEvents="none");
                // Ensure game loop starts only once
                if (!Game.loop) {
                    Game.loop = requestAnimationFrame(Game.gameLoop);
                }
                Game.ui.updateUI();
                console.log("Game started!");
            }

            restartGameBtn.addEventListener("click", () => {
                sendMessageP2P("request_restart_game", null); 
                restartGameLogic();
            });

            function restartGameLogic() {
                console.log("Restarting game logic...");
                if(Game.loop)cancelAnimationFrame(Game.loop);
                Game.loop = null; // Reset loop reference
                Game.isRunning=false; 
                Game.units=[]; 
                Game.targetUnitsState = []; 
                Game.placing=true; 
                Game.winnerText=""; 
                Game.winnerPlayer=null;
                Game.localPlayerReady = false;
                Game.remotePlayerReady = false;

                if(Game.dataChannel && Game.dataChannel.readyState === 'open'){
                    readinessCheckDiv.style.display = 'block';
                    localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã';
                    remoteReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤';
                    playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ"; 
                    playerReadyBtn.style.display = 'inline-block'; 
                    canvas.style.pointerEvents = "auto";
                    document.getElementById("restartGameBtn").style.display = "none";
                    document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "auto");
                    Game.ui.updateUI();
                } else {
                    if (!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,"–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É.");
                    return;
                }
                Game.draw();
                if (Game.isHost) {
                    sendMessageP2P("game_state_update", {
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer,
                        isRunning: Game.isRunning,
                        placing: Game.placing,
                        gameReset: true // Signal to client that game state was reset
                    });
                }
                console.log("Game logic restarted. Placing phase enabled.");
            }
            
            Game.draw = function() {
                ctx.clearRect(0,0,Game.WIDTH,Game.HEIGHT); const gs=20; ctx.strokeStyle='rgba(128,128,128,0.2)';ctx.lineWidth=1;
                for(let x=0;x<=Game.WIDTH;x+=gs){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,Game.HEIGHT);ctx.stroke();}
                for(let y=0;y<=Game.HEIGHT;y+=gs){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(Game.WIDTH,y);ctx.stroke();}
                for(let u of Game.units)u.draw(ctx);
                if(Game.winnerText){
                    const cx=Game.WIDTH/2,cy=Game.HEIGHT/2; ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(cx-150,cy-40,300,80);
                    ctx.textAlign="center";ctx.textBaseline="middle";ctx.font="bold 32px Arial";
                    if(Game.winnerPlayer==="player1"){ctx.fillStyle=Game.COLORS.player1;ctx.shadowColor="#00BFFF";}
                    else if(Game.winnerPlayer==="player2"){ctx.fillStyle=Game.COLORS.player2;ctx.shadowColor="#FF4500";}
                    else{ctx.fillStyle="white";ctx.shadowColor="white";}
                    ctx.shadowBlur=20;ctx.fillText(Game.winnerText,cx,cy);ctx.shadowBlur=0;
                }
            };
            Game.gameLoop = function() {
                if (Game.isHost) {
                    Game.update();
                } else {
                    if (!Game.isRunning && Game.winnerText) {
                        // Game ended, no need to interpolate if winner is shown
                    } else {
                        const nextUnits = [];

                        Game.targetUnitsState.forEach(targetUnitData => {
                            let currentUnit = Game.units.find(u => u.id === targetUnitData.id);

                            if (currentUnit) {
                                // Interpolate towards target position for smoother movement
                                let dx = targetUnitData.x - currentUnit.x;
                                if (Math.abs(dx) > Game.WIDTH / 2) {
                                    dx -= Math.sign(dx) * Game.WIDTH;
                                }
                                currentUnit.x = (currentUnit.x + dx * Game.interpolationFactor + Game.WIDTH) % Game.WIDTH;

                                let dy = targetUnitData.y - currentUnit.y;
                                if (Math.abs(dy) > Game.HEIGHT / 2) {
                                    dy -= Math.sign(dy) * Game.HEIGHT;
                                }
                                currentUnit.y = (currentUnit.y + dy * Game.interpolationFactor + Game.HEIGHT) % Game.HEIGHT;
                                currentUnit.type = targetUnitData.type;
                                currentUnit.player = targetUnitData.player;
                            } else {
                                // If a unit is in targetState but not in current units, create it
                                currentUnit = new Game.Unit(targetUnitData.x, targetUnitData.y, targetUnitData.type, targetUnitData.player, targetUnitData.id);
                            }
                            nextUnits.push(currentUnit);
                        });

                        // Filter out units that are no longer in targetUnitsState
                        Game.units = nextUnits.filter(u => Game.targetUnitsState.some(t => t.id === u.id));
                    }
                }
                Game.draw();
                // Continue loop if game is running or in placing phase
                if ((Game.isRunning && !Game.winnerText) || Game.placing) {
                    Game.loop = requestAnimationFrame(Game.gameLoop);
                } else {
                    // Game ended and winner is displayed, stop loop
                    Game.isRunning = false;
                    if (Game.loop) {
                        cancelAnimationFrame(Game.loop);
                        Game.loop = null;
                    }
                }
            };
            
            function handleCanvasInteraction(clientX, clientY) {
                if (!Game.placing || !Game.dataChannel || Game.dataChannel.readyState !== 'open') return;
                const rect=canvas.getBoundingClientRect(),sX=canvas.width/rect.width,sY=canvas.height/rect.height,x=(clientX-rect.left)*sX,y=(clientY-rect.top)*sY;
                let clickedUnitIdToRemove = null;
                const currentPlayerRole = Game.isHost ? "player1" : "player2";

                for(let i=Game.units.length-1;i>=0;i--){
                    const u=Game.units[i];
                    const dx=u.x-x,dy=u.y-y;
                    if(Math.hypot(dx,dy)<=15){
                        if (u.player === currentPlayerRole) {
                            clickedUnitIdToRemove = u.id;
                            break;
                        } else {
                            return; // Cannot remove opponent's units
                        }
                    }
                }

                if (Game.isHost) {
                    // Host directly modifies game state and broadcasts
                    if (clickedUnitIdToRemove) {
                        Game.units = Game.units.filter(u => u.id !== clickedUnitIdToRemove);
                    } else {
                        const type = Game.selectedTypes[currentPlayerRole], newU = new Game.Unit(x, y, type, currentPlayerRole);
                        Game.units.push(newU);
                    }
                    Game.targetUnitsState = Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player }));

                    Game.ui.updateUI();
                    Game.draw(); // Force draw on host immediately
                    sendMessageP2P("game_state_update", {
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer,
                        isRunning: Game.isRunning,
                        placing: Game.placing
                    });
                } else {
                    // Client sends request to host, updates local state speculatively
                    if (clickedUnitIdToRemove) {
                        sendMessageP2P("unit_placement_request", { player: currentPlayerRole, unitIdToRemove: clickedUnitIdToRemove });
                        // Speculative update for client's UI
                        Game.units = Game.units.filter(u => u.id !== clickedUnitIdToRemove);
                        Game.targetUnitsState = Game.targetUnitsState.filter(u => u.id !== clickedUnitIdToRemove); // Update target state too
                    } else {
                        const type = Game.selectedTypes[currentPlayerRole];
                        const newId = Math.random().toString(36).substr(2, 9); // Client generates ID for its unit
                        sendMessageP2P("unit_placement_request", { player: currentPlayerRole, x: x, y: y, unitId: newId });
                        // Speculative update for client's UI
                        const newU = new Game.Unit(x, y, type, currentPlayerRole, newId);
                        Game.units.push(newU);
                        Game.targetUnitsState.push({ id: newU.id, x: newU.x, y: newU.y, type: newU.type, player: newU.player }); // Update target state too
                    }
                    Game.ui.updateUI();
                    Game.draw(); // Force draw on client immediately after interaction
                }
            }
            canvas.addEventListener("click", e => handleCanvasInteraction(e.clientX, e.clientY));
            canvas.addEventListener("touchstart", e => { if(!Game.placing)return; e.preventDefault(); handleCanvasInteraction(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

            Game.ui.setupTypeButtons();
            resetP2PStateAndUI(false); // Initial reset
            Game.draw(); // Initial draw
        });
    </script>
</body>
</html>
