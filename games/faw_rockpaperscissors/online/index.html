
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta charset="UTF-8" />
    <title>faw_rockpaperscissors: p2p (manual signaling)</title>
    <link rel="icon" href="../icon.png">
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #121212; color: #ddd; margin: 0; padding: 20px; }
        h1, h2, h3 { color: #aaddff; text-shadow: 0 0 6px #88ccff88; }
        h1 { margin-bottom: 20px; } h2 { margin-top: 0; margin-bottom: 15px; } h3 { margin-top: 0; margin-bottom: 10px; }

        .screen { padding: 20px; margin: 0 auto; max-width: 600px; background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; }
        #roleSelectionScreen, #p2pControlsScreen { margin-bottom: 20px; }
        
        .p2p-step { border: 1px solid #444; padding: 15px; margin-top:15px; border-radius: 5px; background-color: #222; }
        .p2p-instruction { font-size: 0.95em; color: #cceeff; margin-bottom: 10px; line-height: 1.4; }
        .p2p-step textarea { width: calc(100% - 22px); min-height: 70px; padding: 10px; margin-bottom: 10px; border-radius: 5px; border: 1px solid #555; background-color: #333; color: #eee; font-family: monospace; resize: vertical; box-sizing: border-box; }
        .p2p-step button, .screen button, #toggleMuteBtnContainer button { font-size: 1rem; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; background-color: #4CAF50; color: white; transition: background-color 0.3s; width: auto; margin-top: 5px; margin-right: 10px; }
        .p2p-step button.secondary, .screen button.secondary, #toggleMuteBtnContainer button.secondary { background-color: #008CBA; }
        .p2p-step button:hover, .screen button:hover, #toggleMuteBtnContainer button:hover { opacity:0.9; }
        .p2p-step button:disabled, .screen button:disabled, #toggleMuteBtnContainer button:disabled { background-color: #555; cursor: not-allowed; }
        .p2p-step hr { border-color: #444; margin: 15px 0; }

        #gameContainer { display: none; }
        #gameWrapper { display: flex; justify-content: center; gap: 20px; align-items: flex-start; max-width: 1100px; margin: 0 auto; flex-wrap: wrap; padding: 0 10px; }
        #gameControls { background-color: #1a1a1a; padding: 15px; border-radius: 8px; width: 280px; display: flex; flex-direction: column; gap: 15px; border: 1px solid #333; color: #ccc; }
        .player-controls { background-color: #2a2a2a; padding: 12px; border-radius: 8px; }
        .type-buttons { display: flex; justify-content: center; gap: 10px; margin-bottom: 10px; flex-wrap: wrap; }
        .type-button { font-size: 1.1rem; padding: 10px 16px; cursor: pointer; border: 2px solid #555; border-radius: 8px; background-color: #2a2a2a; color: #ddd; user-select: none; width: auto; min-width: 70px; }
        .type-button.selected { font-weight: bold; }
        #player1Controls .type-button.selected { border-color: #88ccff; color: #aaddff; }
        #player2Controls .type-button.selected { border-color: #ff6347; color: #ff9b90; }
        #gameCanvas { background-color: #1e1e1e; border: 1px solid #444; border-radius: 8px; cursor: crosshair; width: 100%; max-width: 700px; height: auto; }
        #actions button { width: 100%; margin-top:10px; box-sizing: border-box; }
        .menu-button { background-color: #555555; text-decoration:none; display:inline-block; padding: 12px 24px; text-align:center; color: white; border-radius: 5px; transition: background-color 0.3s; margin-top: 10px; }
        .menu-button:hover { opacity: 0.9; }
        .start-button { background-color: #3a8f3a; color: white; font-weight: bold; }
        .ice-status {font-size: 0.8em; color: #aaa; margin-top: -5px; margin-bottom: 5px; display: block;}
        #readinessCheck p { margin: 5px 0; font-size: 0.9em;}
        #toggleMuteBtnContainer { margin-top: 15px; padding-top:10px; border-top: 1px solid #444;}


        @media (max-width: 768px) {
            body { padding: 10px; }
            .screen { padding: 15px; }
            #gameWrapper { flex-direction: column; align-items: center; padding: 0; }
            #gameControls { width: 100%; max-width: 400px; }
            #gameCanvas { width: 100% !important; max-width: 100%; }
            .p2p-step button, .screen button, #toggleMuteBtnContainer button, .menu-button { width: calc(100% - 20px); margin-left:10px; margin-right:10px; box-sizing:border-box; }
            .p2p-step button:first-of-type { margin-top: 10px; }
        }
    </style>
</head>
<body>
    <h1>Rock, Paper, Scissors: P2P</h1>

    <div id="roleSelectionScreen" class="screen">
        <h2>1. –í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—à—É —Ä–æ–ª—å:</h2>
        <button id="selectHostBtn" class="start-button">–°–æ–∑–¥–∞—Ç—å –ò–≥—Ä—É (–•–æ—Å—Ç)</button>
        <button id="selectClientBtn">–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è –∫ –ò–≥—Ä–µ (–ö–ª–∏–µ–Ω—Ç)</button>
        <a href="../index.html" class="menu-button">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</a>
    </div>

    <div id="p2pControlsScreen" class="screen" style="display:none;">
        <h3>P2P –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ (–®–∞–≥ –∑–∞ –®–∞–≥–æ–º)</h3>
        <p>–í–∞—à–∞ —Ä–æ–ª—å: <strong id="playerRoleDisplay">...</strong> | –°—Ç–∞—Ç—É—Å: <span id="connectionStatus">–û–∂–∏–¥–∞–Ω–∏–µ</span></p>
        <hr>

        <div id="p2pStep_Host_1_CreateOffer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í—ã - –•–æ—Å—Ç. –ù–∞–∂–º–∏—Ç–µ '–°–æ–∑–¥–∞—Ç—å –û—Ñ—Ñ–µ—Ä', —á—Ç–æ–±—ã —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è (SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã). –°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–µ–∫—Å—Ç –∏–∑ –ø–æ–ª—è –Ω–∏–∂–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –ö–ª–∏–µ–Ω—Ç—É.</p>
            <button id="host_createOfferBtn">–°–æ–∑–¥–∞—Ç—å –û—Ñ—Ñ–µ—Ä</button>
            <textarea id="host_localSdpOfferOutput" placeholder="–í–∞—à SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –ø–æ—è–≤—è—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="p2p-instruction" id="host_offerCreatedInstruction" style="display:none;">–í–∞—à –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã —Å–æ–∑–¥–∞–Ω—ã. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏—Ö –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –ö–ª–∏–µ–Ω—Ç—É. –ó–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ '–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É'.</p>
            <button id="host_proceedToSetAnswerBtn" style="display:none;">–ü–µ—Ä–µ–π—Ç–∏ –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —à–∞–≥—É</button>
        </div>

        <div id="p2pStep_Host_2_SetAnswer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction"><b>–ü—Ä–∏–µ–º –û—Ç–≤–µ—Ç–∞ –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞.</b> –í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞ –≤ –ø–æ–ª–µ –Ω–∏–∂–µ –∏ –Ω–∞–∂–º–∏—Ç–µ '–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SDP –û—Ç–≤–µ—Ç'.</p>
            <textarea id="host_remoteSdpAnswerInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞"></textarea>
            <button id="host_setRemoteSdpAnswerBtn" class="secondary">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å SDP –û—Ç–≤–µ—Ç –ö–ª–∏–µ–Ω—Ç–∞</button>
        </div>

        <div id="p2pStep_Client_1_PasteOffer" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í—ã - –ö–ª–∏–µ–Ω—Ç. –í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –•–æ—Å—Ç–∞ –≤ –ø–æ–ª–µ –Ω–∏–∂–µ –∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–∏–Ω—è—Ç—å –û—Ñ—Ñ–µ—Ä –∏ –°–æ–∑–¥–∞—Ç—å –û—Ç–≤–µ—Ç'.</p>
            <textarea id="client_remoteSdpOfferInput" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –•–æ—Å—Ç–∞"></textarea>
            <button id="client_acceptOfferAndProceedToAnswerBtn">–ü—Ä–∏–Ω—è—Ç—å –û—Ñ—Ñ–µ—Ä –∏ –°–æ–∑–¥–∞—Ç—å –û—Ç–≤–µ—Ç</button>
        </div>
        
        <div id="p2pStep_Client_2_CreateAnswerAndSend" class="p2p-step" style="display:none;">
            <p class="p2p-instruction">–í–∞—à SDP –û—Ç–≤–µ—Ç –ø–æ—è–≤–∏—Ç—Å—è –Ω–∏–∂–µ. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –•–æ—Å—Ç—É.</p>
            <textarea id="client_localSdpAnswerOutput" placeholder="–í–∞—à SDP –û—Ç–≤–µ—Ç –ø–æ—è–≤–∏—Ç—Å—è –∑–¥–µ—Å—å..." readonly></textarea>
            <p class="p2p-instruction" id="client_answerCreatedInstruction" style="display:none;">–í–∞—à –û—Ç–≤–µ—Ç —Å–æ–∑–¥–∞–Ω. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ –∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –•–æ—Å—Ç—É.</p>
        </div>

        <div id="toggleMuteBtnContainer" style="display:none;">
            <button id="toggleMuteBtn" class="secondary">–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
        </div>
        <button id="restartP2PConnectionBtn" class="secondary" style="margin-top: 20px; background-color:#c82333;">–ù–∞—á–∞—Ç—å –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <div id="gameContainer">
        <div id="gameWrapper">
            <div id="gameControls">
                <div class="player-controls" id="player1Controls" style="display:none;"> <h2>–ò–≥—Ä–æ–∫ 1 (—Å–∏–Ω–∏–π)</h2>
                    <div class="type-buttons">
                        <button data-type="rock" class="type-button selected">ü™®</button>
                        <button data-type="paper" class="type-button">üìÑ</button>
                        <button data-type="scissors" class="type-button">‚úÇÔ∏è </button>
                    </div>
                    <p>–Æ–Ω–∏—Ç—ã: <span id="player1UnitsCount">0</span></p>
                </div>

                <div class="player-controls" id="player2Controls" style="display:none;"> <h2>–ò–≥—Ä–æ–∫ 2 (–∫—Ä–∞—Å–Ω—ã–π)</h2>
                    <div class="type-buttons">
                        <button data-type="rock" class="type-button selected">ü™®</button>
                        <button data-type="paper" class="type-button">üìÑ</button>
                        <button data-type="scissors" class="type-button">‚úÇÔ∏è </button>
                    </div>
                    <p>–Æ–Ω–∏—Ç—ã: <span id="player2UnitsCount">0</span></p>
                </div>

                <div id="actions">
                    <p>–í—ã –∏–≥—Ä–∞–µ—Ç–µ –∑–∞: <strong id="activePlayerDisplayInGame">–û–∂–∏–¥–∞–Ω–∏–µ</strong></p>
                    <div id="readinessCheck" style="display:none;">
                        <p>–ì–æ—Ç–æ–≤–Ω–æ—Å—Ç—å: –í—ã (<span id="localReadyStatus">–ù–µ –≥–æ—Ç–æ–≤—ã</span>), –û–ø–ø–æ–Ω–µ–Ω—Ç (<span id="remoteReadyStatus">–ù–µ –≥–æ—Ç–æ–≤</span>)</p>
                    </div>
                    <button id="playerReadyBtn" class="start-button" style="display:none;">–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ</button>
                    <button id="restartGameBtn" class="start-button" style="display:none;">–ò–≥—Ä–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
                    <a href="#" id="mainMenuBtnFromGame" class="menu-button">–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é (–ù–æ–≤–æ–µ P2P)</a>
                </div>
            </div>
            <canvas id="gameCanvas" width="700" height="500"></canvas>
        </div>
    </div>
    <audio id="remoteAudio" autoplay style="display:none;"></audio>

    <script>
const Game = {
            WIDTH: 700, HEIGHT: 500, TYPES: ["rock", "paper", "scissors"], EMOJIS: { rock: "ü™®", paper: "üìÑ", scissors: "‚úÇÔ∏è" }, COLORS: { player1: "#87CEFA", player2: "#FF6347" },
            units: [],
            targetUnitsState: [], // –ù–æ–≤–æ–µ: –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ü–µ–ª–µ–≤—ã—Ö –ø–æ–∑–∏—Ü–∏–π, –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –æ—Ç —Ö–æ—Å—Ç–∞
            interpolationFactor: 0.2, // –ù–æ–≤–æ–µ: –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ (–Ω–∞—Å—Ç—Ä–æ–π—Ç–µ –ø–æ –∂–µ–ª–∞–Ω–∏—é)
            placing: true, selectedTypes: { player1: "rock", player2: "rock" }, loop: null, winnerText: "", winnerPlayer: null, isRunning: false,
            isHost: false, peerConnection: null, dataChannel: null,
            localPlayerReady: false, remotePlayerReady: false,
            localStream: null, // For voice chat
            lastStateBroadcastTime: 0,
            stateBroadcastInterval: 100 // Milliseconds between state broadcasts
        };
        // Game class Unit, helper functions (wrapDistance, shouldChase, etc.), Game.update, Game.checkWinCondition, Game.showWinner (mostly unchanged)
        (function(ns){
            class Unit {
                constructor(x, y, type, player, id = null) {
                    this.id = id || Math.random().toString(36).substr(2, 9);
                    this.x = x; this.y = y;
                    this.targetX = x; // –ù–æ–≤–æ–µ: —Ü–µ–ª–µ–≤–∞—è X –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
                    this.targetY = y; // –ù–æ–≤–æ–µ: —Ü–µ–ª–µ–≤–∞—è Y –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞
                    this.type = type; this.player = player;
                    this.vx = Math.random() * 2 - 1; this.vy = Math.random() * 2 - 1;
                    this.radius = 12; this.spawnTime = Date.now(); this.nextDashTime = Date.now() + this.getRandomDashInterval();
                }
                getRandomDashInterval() { return 2000 + Math.random() * 3000; }
                dash() { const d = 5 + Math.random()*10, s = Math.hypot(this.vx,this.vy)||1; this.vx += (this.vx/s)*d; this.vy += (this.vy/s)*d; this.nextDashTime = Date.now() + this.getRandomDashInterval(); }
                move() {
                    if (Date.now() >= this.nextDashTime) this.dash();
                    let target = null, minDist = Infinity;
                    for (const other of ns.units) {
                        if (other === this || other.player === this.player) continue;
                        if (shouldChase(this.type, other.type) || shouldFlee(this.type, other.type)) {
                            const dx = wrapDistance(this.x, other.x, ns.WIDTH), dy = wrapDistance(this.y, other.y, ns.HEIGHT), dist = Math.hypot(dx, dy);
                            if (dist < minDist) { minDist = dist; target = other; }
                        }
                    }
                    const baseSpeed = 1.5;
                    if (target) {
                        const dx = wrapDistance(this.x, target.x, ns.WIDTH), dy = wrapDistance(this.y, target.y, ns.HEIGHT), d = Math.hypot(dx, dy) + 0.01;
                        if (shouldChase(this.type, target.type)) { this.vx += (dx/d)*baseSpeed*0.1; this.vy += (dy/d)*baseSpeed*0.1; }
                        else if (shouldFlee(this.type, target.type)) { this.vx -= (dx/d)*baseSpeed*0.1; this.vy -= (dy/d)*baseSpeed*0.1; }
                    }
                    for (const other of ns.units) {
                        if (other === this || other.player !== this.player) continue;
                        const dx = wrapDistance(this.x, other.x, ns.WIDTH), dy = wrapDistance(this.y, other.y, ns.HEIGHT), dist = Math.hypot(dx, dy);
                        if (dist > 0 && dist < this.radius * 2) { const r = 1.5; this.vx -= (dx/dist)*r*0.05; this.vy -= (dy/dist)*r*0.05; }
                    }
                    this.vx *= 0.95; this.vy *= 0.95;
                    this.x = (this.x + this.vx + ns.WIDTH)%ns.WIDTH; this.y = (this.y + this.vy + ns.HEIGHT)%ns.HEIGHT;
                }
                draw(ctx) {
                    ctx.save(); ctx.translate(this.x, this.y); const age = Date.now() - this.spawnTime;
                    if (age < 1000) ctx.globalAlpha = 0.5 + 0.5 * (age / 1000);
                    ctx.font = "20px serif"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.shadowColor = ns.COLORS[this.player]; ctx.shadowBlur = 6; ctx.fillStyle = ns.COLORS[this.player];
                    ctx.fillText(ns.EMOJIS[this.type],0,0); ctx.restore();
                }
            }
            ns.Unit = Unit;
            function wrapDistance(a,b,size){let d=b-a; if(Math.abs(d)>size/2)d-=Math.sign(d)*size; return d;}
            function shouldChase(t1,t2){const m={rock:"scissors",scissors:"paper",paper:"rock"}; return m[t1]===t2;}
            function shouldFlee(t1,t2){const m={rock:"paper",paper:"scissors",scissors:"rock"}; return m[t1]===t2;}
            function beats(t1,t2){return shouldChase(t1,t2);}
            function resolveConflict(a,b){
                let changed=false;
                if(beats(a.type,b.type)){b.type=a.type;b.player=a.player;changed=true;}
                else if(beats(b.type,a.type)){a.type=b.type;a.player=b.player;changed=true;}
            }
            ns.update = function(){
                // Only host runs game logic (movement, collisions etc.)
                if (!ns.isHost) return;

                if (ns.isRunning) { // Movement and collisions only if running
                    for(let u of ns.units) u.move();
                    for (let i=0; i<ns.units.length; i++){
                        for (let j=i+1; j<ns.units.length; j++){
                            const a=ns.units[i], b=ns.units[j];
                            if(a.player === b.player) continue;
                            const dx = wrapDistance(a.x,b.x,ns.WIDTH), dy = wrapDistance(a.y,b.y,ns.HEIGHT), dist = Math.hypot(dx,dy);
                            if(dist < 24 && a.type !== b.type){
                                resolveConflict(a,b);
                                const overlap=24-dist,nx=dx/dist,ny=dy/dist;
                                a.x-=nx*overlap*0.5;a.y-=ny*overlap*0.5;b.x+=nx*overlap*0.5;b.y+=ny*overlap*0.5;
                            }
                        }
                    }
                }
                
                checkWinCondition();

                // Broadcast state if host and game is running OR placing
                if (ns.isHost && (ns.isRunning || ns.placing) && Date.now() - ns.lastStateBroadcastTime > ns.stateBroadcastInterval) {
                    sendMessageP2P("game_state_update", {
                        units: ns.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })), // Send serializable data
                        winnerText: ns.winnerText,
                        winnerPlayer: ns.winnerPlayer,
                        isRunning: ns.isRunning,
                        placing: ns.placing
                    });
                    ns.lastStateBroadcastTime = Date.now();
                }
            };
            function checkWinCondition(){
                if(ns.placing)return;
                const p1U=ns.units.filter(u=>u.player==="player1"), p2U=ns.units.filter(u=>u.player==="player2");
                let gameEnded = false; // –§–ª–∞–≥, —á—Ç–æ–±—ã –∑–Ω–∞—Ç—å, –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å –ª–∏ –∏–≥—Ä–∞
                if(ns.units.length===0 && !ns.placing){showWinner("–ù–∏—á—å—è! (–ù–µ—Ç —é–Ω–∏—Ç–æ–≤)",null); gameEnded = true;}
                else if(p1U.length===0 && ns.units.length>0){showWinner("–ò–≥—Ä–æ–∫ 2 –ø–æ–±–µ–¥–∏–ª!","player2"); gameEnded = true;}
                else if(p2U.length===0 && ns.units.length>0){showWinner("–ò–≥—Ä–æ–∫ 1 –ø–æ–±–µ–¥–∏–ª!","player1"); gameEnded = true;}
                else {
                    const p1CB=p1U.some(u1=>p2U.some(u2=>shouldChase(u1.type,u2.type))), p2CB=p2U.some(u2=>p1U.some(u1=>shouldChase(u2.type,u1.type)));
                    if(!p1CB && !p2CB && ns.units.length>0){
                        if(p1U.length>p2U.length)showWinner("–ò–≥—Ä–æ–∫ 1 –ø–æ–±–µ–¥–∏–ª!","player1");
                        else if(p2U.length>p1U.length)showWinner("–ò–≥—Ä–æ–∫ 2 –ø–æ–±–µ–¥–∏–ª!","player2");
                        else showWinner("–ù–∏—á—å—è!",null);
                        gameEnded = true;
                    }
                }

                if (gameEnded && ns.isHost) {
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è, –µ—Å–ª–∏ –∏–≥—Ä–∞ –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å
                    sendMessageP2P("game_state_update", {
                        units: ns.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        winnerText: ns.winnerText,
                        winnerPlayer: ns.winnerPlayer,
                        isRunning: ns.isRunning, // –≠—Ç–æ –±—É–¥–µ—Ç false –ø–æ—Å–ª–µ showWinner
                        placing: ns.placing
                    });
                }
            }
            function showWinner(text,player){
                ns.winnerText=text; ns.winnerPlayer=player; ns.isRunning=false;
                if(document.getElementById("restartGameBtn"))document.getElementById("restartGameBtn").style.display="block";
                if(document.getElementById("playerReadyBtn"))document.getElementById("playerReadyBtn").style.display="none";
                if(document.getElementById("readinessCheck"))document.getElementById("readinessCheck").style.display="none";
                document.querySelectorAll(".type-buttons").forEach(c=>c.style.pointerEvents="none");
            }
        })(Game);
        
        (function(ns) { // ui.js
            const p1CtrlElement = document.getElementById("player1Controls");
            const p2CtrlElement = document.getElementById("player2Controls");
            const activePlayerDispGame = document.getElementById("activePlayerDisplayInGame");
            const p1UnitsSpan = document.getElementById("player1UnitsCount");
            const p2UnitsSpan = document.getElementById("player2UnitsCount");

            function updatePlayerButtons(container, player) {
                container.querySelectorAll(".type-button").forEach(btn => {
                    btn.classList.toggle("selected", ns.selectedTypes[player] === btn.getAttribute("data-type"));
                });
            }
            ns.ui = {
                updateUI: function() {
                    if (ns.isHost) {
                        activePlayerDispGame.textContent = "–ò–≥—Ä–æ–∫ 1 (–í—ã - —Å–∏–Ω–∏–π)";
                        p1CtrlElement.style.display = "block";
                        p1CtrlElement.style.pointerEvents = (ns.placing || !ns.isRunning) ? "auto" : "none";
                        p2CtrlElement.style.display = "none"; // Host doesn't need P2 controls
                        updatePlayerButtons(p1CtrlElement, "player1");
                    } else { // Client
                        activePlayerDispGame.textContent = "–ò–≥—Ä–æ–∫ 2 (–í—ã - –∫—Ä–∞—Å–Ω—ã–π)";
                        p1CtrlElement.style.display = "none"; // Client doesn't need P1 controls
                        p2CtrlElement.style.display = "block";
                        p2CtrlElement.style.pointerEvents = (ns.placing || !ns.isRunning) ? "auto" : "none";
                        updatePlayerButtons(p2CtrlElement, "player2");
                    }
                                        
                    p1UnitsSpan.textContent = ns.units.filter(u=>u.player==="player1").length;
                    p2UnitsSpan.textContent = ns.units.filter(u=>u.player==="player2").length;
                },
                setupTypeButtons: function() {
                    [...p1CtrlElement.querySelectorAll(".type-button"), ...p2CtrlElement.querySelectorAll(".type-button")].forEach(btn => {
                        const handler = () => {
                            const player = btn.closest(".player-controls").id === "player1Controls" ? "player1" : "player2";
                            // Only allow local player to change their selected type
                            if ((ns.isHost && player === "player1") || (!ns.isHost && player === "player2")) {
                                ns.selectedTypes[player] = btn.getAttribute("data-type");
                                // Send selected type to opponent (Host will handle player2's type, Client will send its own)
                                if (ns.isHost && player === "player1") { // If host changes its own type, inform client
                                    sendMessageP2P("selected_type", { player: "player1", type: ns.selectedTypes.player1 });
                                } else if (!ns.isHost && player === "player2") { // If client changes its own type, inform host
                                    sendMessageP2P("selected_type", { player: "player2", type: ns.selectedTypes.player2 });
                                }
                            } else return; // Prevent changing opponent's type locally
                            ns.ui.updateUI();
                        };
                        btn.addEventListener("click", handler);
                        btn.addEventListener("touchstart", e=>{ e.preventDefault(); handler(); }, {passive:false});
                    });
                }
            };
        })(Game);

        let sendMessageP2P;
        document.addEventListener("DOMContentLoaded", function () {
            const rtcConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }, { urls: "stun:stun1.l.google.com:19302" }] };
            const roleScreen = document.getElementById("roleSelectionScreen");
            const p2pScreen = document.getElementById("p2pControlsScreen");
            const gameScreen = document.getElementById("gameContainer");

            const playerRoleDisp = document.getElementById("playerRoleDisplay");
            const connectionStatusSpan = document.getElementById("connectionStatus");
            
            const hostStep1 = document.getElementById("p2pStep_Host_1_CreateOffer");
            const hostStep2 = document.getElementById("p2pStep_Host_2_SetAnswer");
            const clientStep1 = document.getElementById("p2pStep_Client_1_PasteOffer");
            const clientStep2 = document.getElementById("p2pStep_Client_2_CreateAnswerAndSend");

            const host_createOfferBtn = document.getElementById("host_createOfferBtn");
            const host_localSdpOfferOutput = document.getElementById("host_localSdpOfferOutput");
            const host_offerCreatedInstruction = document.getElementById("host_offerCreatedInstruction");
            const host_proceedToSetAnswerBtn = document.getElementById("host_proceedToSetAnswerBtn");
            const host_remoteSdpAnswerInput = document.getElementById("host_remoteSdpAnswerInput");
            const host_setRemoteSdpAnswerBtn = document.getElementById("host_setRemoteSdpAnswerBtn");

            const client_remoteSdpOfferInput = document.getElementById("client_remoteSdpOfferInput");
            const client_acceptOfferAndProceedToAnswerBtn = document.getElementById("client_acceptOfferAndProceedToAnswerBtn");
            const client_localSdpAnswerOutput = document.getElementById("client_localSdpAnswerOutput");
            const client_answerCreatedInstruction = document.getElementById("client_answerCreatedInstruction");
            
            const restartP2PBtn = document.getElementById("restartP2PConnectionBtn");
            const mainMenuFromGameBtn = document.getElementById("mainMenuBtnFromGame");
            const toggleMuteBtnContainer = document.getElementById("toggleMuteBtnContainer");
            const toggleMuteBtn = document.getElementById("toggleMuteBtn");
            const remoteAudioElement = document.getElementById("remoteAudio");


            const playerReadyBtn = document.getElementById("playerReadyBtn");
            const restartGameBtn = document.getElementById("restartGameBtn");
            const readinessCheckDiv = document.getElementById("readinessCheck");
            const localReadyStatusSpan = document.getElementById("localReadyStatus");
            const remoteReadyStatusSpan = document.getElementById("remoteReadyStatus");
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            let readyCheckTimeout = null; // –î–ª—è —Ç–∞–π–º–∞—É—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏

            function updateP2PStatus(statusText) { connectionStatusSpan.textContent = statusText; }
            function showP2PStep(stepIdToShow) {
                [hostStep1, hostStep2, clientStep1, clientStep2].forEach(s => s.style.display = 'none');
                if (document.getElementById(stepIdToShow)) document.getElementById(stepIdToShow).style.display = 'block';
            }
            function resetP2PStateAndUI(showAlert = true, message = "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å–±—Ä–æ—à–µ–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ.") {
                if (showAlert && !resetP2PStateAndUI.isResetting) {
                    resetP2PStateAndUI.isResetting = true; alert(message); resetP2PStateAndUI.isResetting = false;
                }
                if (Game.peerConnection) { Game.peerConnection.close(); Game.peerConnection = null; }
                if (Game.dataChannel) { Game.dataChannel.close(); Game.dataChannel = null; }
                if (Game.localStream) { Game.localStream.getTracks().forEach(track => track.stop()); Game.localStream = null; toggleMuteBtnContainer.style.display = 'none';}

                Game.isHost = false;
                Game.localPlayerReady = false; Game.remotePlayerReady = false;
                
                // Clear any pending timeout
                if (readyCheckTimeout) {
                    clearTimeout(readyCheckTimeout);
                    readyCheckTimeout = null;
                }

                [host_localSdpOfferOutput, host_remoteSdpAnswerInput,
                 client_remoteSdpOfferInput, client_localSdpAnswerOutput]
                 .forEach(ta => { if(ta) ta.value = ""; });
                [
                    host_offerCreatedInstruction, host_proceedToSetAnswerBtn,
                    client_answerCreatedInstruction
                ]
                 .forEach(el => { if(el) el.style.display = "none"; });

                roleScreen.style.display = 'block'; p2pScreen.style.display = 'none'; gameScreen.style.display = 'none';
                updateP2PStatus("–û—Ç–∫–ª—é—á–µ–Ω–æ");
            }
            resetP2PStateAndUI.isResetting = false;

            restartP2PBtn.addEventListener("click", () => resetP2PStateAndUI(false));
            mainMenuFromGameBtn.addEventListener("click", (e) => {
                e.preventDefault();
                resetP2PStateAndUI(false);
                Game.units = []; Game.targetUnitsState = []; Game.winnerText = ""; Game.isRunning = false; if(Game.loop) cancelAnimationFrame(Game.loop); Game.draw();
            });

            let isMuted = false;
            toggleMuteBtn.addEventListener('click', () => {
                if (Game.localStream) {
                    Game.localStream.getAudioTracks().forEach(track => {
                        track.enabled = !track.enabled;
                    });
                    isMuted = !Game.localStream.getAudioTracks()[0]?.enabled;
                    toggleMuteBtn.textContent = isMuted ? "–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω" : "–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω";
                }
            });


            sendMessageP2P = function(type, payload) {
                if (Game.dataChannel && Game.dataChannel.readyState === "open") {
                    try {
                        Game.dataChannel.send(JSON.stringify({ type, payload }));
                    } catch (e) {
                        console.error("Error sending P2P message:", e);
                    }
                } else {
                    console.warn("DataChannel not open for P2P message:", type);
                }
            }

            async function initPeerConnection() {
                if (Game.peerConnection) { Game.peerConnection.close(); }
                Game.peerConnection = new RTCPeerConnection(rtcConfig);

                if (Game.localStream) {
                    Game.localStream.getTracks().forEach(track => {
                        Game.peerConnection.addTrack(track, Game.localStream);
                    });
                }

                Game.peerConnection.ontrack = event => {
                    console.log("Remote track received:", event.track, event.streams);
                    if (remoteAudioElement && event.streams && event.streams[0]) {
                        if (remoteAudioElement.srcObject !== event.streams[0]) {
                             remoteAudioElement.srcObject = event.streams[0];
                             console.log("Remote audio stream assigned.");
                        }
                    }
                };

                Game.peerConnection.onconnectionstatechange = () => {
                    const state = Game.peerConnection.connectionState;
                    updateP2PStatus(state);
                    if (state === "failed" || state === "disconnected" || state === "closed") {
                         if (!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true, `P2P —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ ${state}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.`);
                    }
                };
                if (Game.isHost) {
                    Game.dataChannel = Game.peerConnection.createDataChannel("gameChannel");
                    setupDataChannelEvents(Game.dataChannel);
                } else {
                    Game.peerConnection.ondatachannel = event => {
                        Game.dataChannel = event.channel;
                        setupDataChannelEvents(Game.dataChannel);
                    };
                }
            }
            
            function setupDataChannelEvents(channel) {
                channel.onopen = () => {
                    updateP2PStatus("P2P –ö–∞–Ω–∞–ª –û—Ç–∫—Ä—ã—Ç - –°–æ–µ–¥–∏–Ω–µ–Ω–æ!");
                    p2pScreen.style.display = 'none'; gameScreen.style.display = 'block';
                    Game.placing = true; Game.localPlayerReady = false; Game.remotePlayerReady = false;
                    readinessCheckDiv.style.display = 'block';
                    localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã'; remoteReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤';
                    playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ"; playerReadyBtn.style.display = 'inline-block'; // playerReadyBtn.disabled = false; removed disable
                    Game.units = []; // –û—á–∏—â–∞–µ–º —é–Ω–∏—Ç—ã –ø—Ä–∏ –Ω–æ–≤–æ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–∏
                    Game.targetUnitsState = []; // –û—á–∏—â–∞–µ–º —Ü–µ–ª–µ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                    Game.ui.updateUI(); Game.draw(); // Initial draw with current units
                };
                channel.onmessage = event => {
                    try { const msg = JSON.parse(event.data); handleP2PMessage(msg.type, msg.payload); }
                    catch (e) { console.error("Error parsing P2P message:", e, event.data); }
                };
                channel.onclose = () => { if(!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,"P2P –ö–∞–Ω–∞–ª –¥–∞–Ω–Ω—ã—Ö –∑–∞–∫—Ä—ã—Ç.") };
                channel.onerror = error => { if(!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,`–û—à–∏–±–∫–∞ P2P –ö–∞–Ω–∞–ª–∞ –¥–∞–Ω–Ω—ã—Ö: ${error}`) };
            }
            
            function handleP2PMessage(type, payload) {
                switch (type) {
                    case "player_readiness":
                        Game.remotePlayerReady = payload.ready;
                        remoteReadyStatusSpan.textContent = Game.remotePlayerReady ? '–ì–æ—Ç–æ–≤' : '–ù–µ –≥–æ—Ç–æ–≤';
                        if (Game.isHost) checkStartConditions();
                        break;
                    case "selected_type":
                        if (payload.player === "player1") Game.selectedTypes.player1 = payload.type;
                        if (payload.player === "player2") Game.selectedTypes.player2 = payload.type;
                        Game.ui.updateUI(); // Update UI for changes in selected types
                        break;
                    case "force_restart_game": // OLD, not used anymore if client requests restart
                        restartGameLogic();
                        break;
                    case "request_restart_game": // NEW: Client requests host to restart game
                        if (Game.isHost) {
                            restartGameLogic(); // Host restarts
                            // Host will automatically broadcast game_state_update due to restartGameLogic() and Game.update()
                        }
                        break;
                    case "start_game": // New message type: Host tells client to start game
                        if (!Game.isHost) { // Only client needs to react to this
                            startGameLogic();
                        }
                        break;
                    case "unit_placement_request": // Client requests unit placement/removal
                        if (Game.isHost) {
                            const { x, y, unitIdToRemove, player, unitId } = payload; // Added unitId for client-generated ID
                            if (unitIdToRemove) { // Remove unit
                                Game.units = Game.units.filter(u => u.id !== unitIdToRemove);
                            } else { // Add unit
                                const type = Game.selectedTypes[player];
                                // Use client-provided unitId if available, otherwise generate new
                                const newU = new Game.Unit(x, y, type, player, unitId); 
                                Game.units.push(newU);
                            }
                            // Host processes and then broadcasts new state
                            Game.ui.updateUI(); // Update host's UI immediately
                            Game.draw(); // Force draw on host immediately after client's unit placement
                            // Host's targetUnitsState is always its Game.units
                            Game.targetUnitsState = Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player }));
                            sendMessageP2P("game_state_update", { // Force broadcast after placement
                                units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })), // Send serializable data
                                winnerText: Game.winnerText,
                                winnerPlayer: Game.winnerPlayer,
                                isRunning: Game.isRunning,
                                placing: Game.placing
                            });
                        }
                        break;
                    case "game_state_update": // Client receives state update from Host
                        if (!Game.isHost) {
                            // Update target state and game status variables
                            Game.targetUnitsState = payload.units; // Directly use the payload units as target
                            Game.winnerText = payload.winnerText;
                            Game.winnerPlayer = payload.winnerPlayer;
                            Game.isRunning = payload.isRunning;
                            Game.placing = payload.placing;

                            // NEW: If gameReset flag is true, explicitly reset client's local readiness
                            if (payload.gameReset) {
                                Game.localPlayerReady = false;
                                // Also ensure the readiness UI is updated for the client itself
                                localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã';
                                playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ";
                                playerReadyBtn.style.display = 'inline-block'; // Ensure button is visible
                                readinessCheckDiv.style.display = 'block'; // Ensure readiness status is visible
                            }

                            // If the game state update means game is running, ensure client's loop starts
                            // Or if placing, ensure client's loop starts to render units
                            if ((Game.isRunning || Game.placing) && !Game.loop) { // Modified condition here
                                Game.loop = requestAnimationFrame(Game.gameLoop);
                            } else if (!Game.isRunning && Game.loop && Game.winnerText) {
                                // If game stopped and there's a winner, cancel animation frame
                                cancelAnimationFrame(Game.loop);
                                Game.loop = null;
                            }


                            Game.ui.updateUI();
                            Game.draw(); // Force a draw on the client after state update for immediate visual feedback

                            if (!Game.isRunning && Game.winnerText) {
                                document.getElementById("restartGameBtn").style.display = "block";
                                document.getElementById("playerReadyBtn").style.display = "none";
                                document.getElementById("readinessCheck").style.display = "none";
                                document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "none");
                            } else if (Game.placing) {
                                document.getElementById("restartGameBtn").style.display = "none";
                                document.getElementById("playerReadyBtn").style.display = "inline-block";
                                document.getElementById("readinessCheck").style.display = "block";
                                document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "auto"); // Re-enable for client to select type
                            }
                        }
                        break;
                    default: console.warn("Unknown P2P message type:", type);
                }
            }

            async function initializeRole(isHostRole) {
                Game.isHost = isHostRole;
                playerRoleDisp.textContent = isHostRole ? "–•–æ—Å—Ç (–ò–≥—Ä–æ–∫ 1)" : "–ö–ª–∏–µ–Ω—Ç (–ò–≥—Ä–æ–∫ 2)";
                let roleTextSuffix = "";

                try {
                    Game.localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true }, video: false });
                    console.log("Microphone access granted.");
                    toggleMuteBtnContainer.style.display = 'block';
                    toggleMuteBtn.textContent = "–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω";
                    isMuted = false;
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    // Simply set stream to null and hide the mute button, no alert
                    Game.localStream = null;
                    toggleMuteBtnContainer.style.display = 'none';
                    roleTextSuffix = " (–ë–µ–∑ –∑–≤—É–∫–∞)";
                }
                playerRoleDisp.textContent = (isHostRole ? "–•–æ—Å—Ç (–ò–≥—Ä–æ–∫ 1)" : "–ö–ª–∏–µ–Ω—Ç (–ò–≥—Ä–æ–∫ 2)") + roleTextSuffix;
                
                roleScreen.style.display = 'none'; p2pScreen.style.display = 'block';
                if (isHostRole) {
                    showP2PStep('p2pStep_Host_1_CreateOffer'); updateP2PStatus("–û–∂–∏–¥–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ñ—Ñ–µ—Ä–∞");
                } else {
                    showP2PStep('p2pStep_Client_1_PasteOffer'); updateP2PStatus("–û–∂–∏–¥–∞–Ω–∏–µ –û—Ñ—Ñ–µ—Ä–∞ –æ—Ç –•–æ—Å—Ç–∞");
                }
            }

            document.getElementById("selectHostBtn").addEventListener("click", () => initializeRole(true));
            document.getElementById("selectClientBtn").addEventListener("click", () => initializeRole(false));
            
            // Host creates Offer and gathers ICE candidates
            host_createOfferBtn.addEventListener("click", async () => {
                await initPeerConnection();
                try {
                    const offer = await Game.peerConnection.createOffer();
                    await Game.peerConnection.setLocalDescription(offer);

                    let iceCandidates = [];
                    // Use a Promise to wait for ICE gathering to complete or timeout
                    const iceGatheringPromise = new Promise(resolve => {
                        Game.peerConnection.onicecandidate = event => {
                            if (event.candidate) {
                                iceCandidates.push(event.candidate.toJSON());
                            } else {
                                // null candidate indicates end of ICE gathering
                                resolve();
                            }
                        };
                        // Fallback timeout for ICE gathering completion (some browsers might not send null candidate consistently)
                        setTimeout(() => {
                            resolve(); // Resolve anyway after timeout
                        }, 2000); // Wait 2 seconds for ICE candidates
                    });

                    await iceGatheringPromise; // Wait for ICE gathering to finish or timeout

                    outputCombinedOffer(iceCandidates);
                    updateP2PStatus("–û—Ñ—Ñ–µ—Ä –∏ ICE —Å–æ–∑–¥–∞–Ω—ã. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏—Ö –ö–ª–∏–µ–Ω—Ç—É.");

                } catch (e) { resetP2PStateAndUI(true, `–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ñ—Ñ–µ—Ä–∞: ${e}`); }
            });

            function outputCombinedOffer(iceCandidates) {
                if (Game.peerConnection && Game.peerConnection.localDescription) {
                    const combinedOffer = {
                        sdp: btoa(Game.peerConnection.localDescription.sdp), // Encode SDP
                        type: Game.peerConnection.localDescription.type,
                        iceCandidates: btoa(JSON.stringify(iceCandidates)) // Encode ICE candidates
                    };
                    host_localSdpOfferOutput.value = JSON.stringify(combinedOffer, null, 2);
                    host_offerCreatedInstruction.style.display = 'block';
                    host_proceedToSetAnswerBtn.style.display = 'inline-block';
                } else {
                    console.error("Cannot output combined offer: PeerConnection or localDescription is null.");
                }
            }

            host_proceedToSetAnswerBtn.addEventListener("click", () => showP2PStep('p2pStep_Host_2_SetAnswer'));
            
            // Host sets Remote SDP Answer
            host_setRemoteSdpAnswerBtn.addEventListener("click", async () => {
                if (!Game.peerConnection) { alert("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ!"); return; }
                if (!host_remoteSdpAnswerInput.value) { alert("–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ç–≤–µ—Ç –æ—Ç –ö–ª–∏–µ–Ω—Ç–∞!"); return; }
                try {
                    const combinedAnswer = JSON.parse(host_remoteSdpAnswerInput.value);
                    const sdp = atob(combinedAnswer.sdp); // Decode SDP
                    const answer = { sdp: sdp, type: combinedAnswer.type };

                    await Game.peerConnection.setRemoteDescription(new RTCSessionDescription(answer));

                    const iceCandidates = JSON.parse(atob(combinedAnswer.iceCandidates || btoa('[]'))); // Decode ICE candidates
                    for (const candidate of iceCandidates) {
                        if (candidate) {
                            try {
                                await Game.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.warn("Error adding ICE candidate (Host):", e);
                            }
                        }
                    }
                    updateP2PStatus("SDP –û—Ç–≤–µ—Ç –ö–ª–∏–µ–Ω—Ç–∞ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω. –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç—Å—è.");
                } catch (e) { alert(`–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ SDP –û—Ç–≤–µ—Ç–∞: ${e}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ—Ä–º–∞—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.`); }
            });

            // Client accepts Offer and creates Answer
            client_acceptOfferAndProceedToAnswerBtn.addEventListener("click", async () => {
                if (!client_remoteSdpOfferInput.value) { alert("–í—Å—Ç–∞–≤—å—Ç–µ SDP –û—Ñ—Ñ–µ—Ä –∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç—ã –æ—Ç –•–æ—Å—Ç–∞!"); return; }
                await initPeerConnection();
                try {
                    const combinedOffer = JSON.parse(client_remoteSdpOfferInput.value);
                    const sdp = atob(combinedOffer.sdp); // Decode SDP
                    const offer = { sdp: sdp, type: combinedOffer.type };
                    const iceCandidates = JSON.parse(atob(combinedOffer.iceCandidates || btoa('[]'))); // Decode ICE candidates

                    await Game.peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                    
                    // Add Host's ICE candidates
                    for (const candidate of iceCandidates) {
                        if (candidate) {
                            try {
                                await Game.peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                            } catch (e) {
                                console.warn("Error adding ICE candidate (Client):", e);
                            }
                        }
                    }
                    
                    const answer = await Game.peerConnection.createAnswer();
                    await Game.peerConnection.setLocalDescription(answer);

                    const combinedAnswer = {
                        sdp: btoa(answer.sdp), // Encode SDP
                        type: answer.type,
                        iceCandidates: btoa(JSON.stringify([])) // Client doesn't gather candidates for the answer
                    };

                    client_localSdpAnswerOutput.value = JSON.stringify(combinedAnswer, null, 2);
                    client_answerCreatedInstruction.style.display = 'block';
                    showP2PStep('p2pStep_Client_2_CreateAnswerAndSend');
                    updateP2PStatus("–û—Ñ—Ñ–µ—Ä –•–æ—Å—Ç–∞ –ø—Ä–∏–Ω—è—Ç. –í–∞—à –û—Ç–≤–µ—Ç —Å–æ–∑–¥–∞–Ω. –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ–≥–æ –•–æ—Å—Ç—É.");

                    Game.peerConnection.onicecandidate = null; // Detach to avoid unnecessary console logs

                } catch (e) { resetP2PStateAndUI(true, `–û—à–∏–±–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è –û—Ñ—Ñ–µ—Ä–∞ –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏—è –û—Ç–≤–µ—Ç–∞: ${e}. –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —Ñ–æ—Ä–º–∞—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω.`);}
            });


            playerReadyBtn.addEventListener("click", () => {
                Game.localPlayerReady = !Game.localPlayerReady;
                localReadyStatusSpan.textContent = Game.localPlayerReady ? '–ì–æ—Ç–æ–≤' : '–ù–µ –≥–æ—Ç–æ–≤—ã';
                playerReadyBtn.textContent = Game.localPlayerReady ? "–û–∂–∏–¥–∞–Ω–∏–µ –æ–ø–ø–æ–Ω–µ–Ω—Ç–∞..." : "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ";
                // playerReadyBtn.disabled = Game.localPlayerReady; // –£–±—Ä–∞–Ω–æ –æ—Ç–∫–ª—é—á–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
                sendMessageP2P("player_readiness", { ready: Game.localPlayerReady });
                if (Game.isHost) checkStartConditions();
            });

            function checkStartConditions() {
                if (Game.isHost && Game.localPlayerReady && Game.remotePlayerReady) {
                    // –û–±–∞ –≥–æ—Ç–æ–≤—ã, –ø—ã—Ç–∞–µ–º—Å—è –Ω–∞—á–∞—Ç—å –∏–≥—Ä—É.
                    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ start_game, –∞ —Ç–∞–∫–∂–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç –Ω–∞ –ø–æ–≤—Ç–æ—Ä–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É.
                    startGameLogic();
                    sendMessageP2P("start_game", {
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        placing: Game.placing,
                        isRunning: Game.isRunning,
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer
                    });

                    // –£—Å—Ç–∞–Ω–æ–≤–∏–º —Ç–∞–π–º–∞—É—Ç –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –æ—Ç–ø—Ä–∞–≤–∫–∏, –µ—Å–ª–∏ –∏–≥—Ä–∞ –Ω–µ –Ω–∞—á–∞–ª–∞—Å—å
                    // (—Ç.–µ. –µ—Å–ª–∏ Game.isRunning –≤—Å–µ –µ—â–µ false —á–µ—Ä–µ–∑ –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è)
                    if (!Game.isRunning && readyCheckTimeout === null) {
                        readyCheckTimeout = setTimeout(() => {
                            if (Game.isHost && Game.localPlayerReady && Game.remotePlayerReady && !Game.isRunning) {
                                console.warn("Timeout: Both players ready, but game not started. Resending start_game message.");
                                sendMessageP2P("start_game", {
                                    units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                                    placing: Game.placing,
                                    isRunning: Game.isRunning,
                                    winnerText: Game.winnerText,
                                    winnerPlayer: Game.winnerPlayer
                                });
                                // –ú–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–æ–≤—ã–π —Ç–∞–π–º–∞—É—Ç –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –∂–¥–∞—Ç—å —Å–ª–µ–¥—É—é—â–µ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è
                                // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã, –∑–¥–µ—Å—å –ø—Ä–æ—Å—Ç–æ –æ–¥–Ω–æ–∫—Ä–∞—Ç–Ω–∞—è –ø–æ–≤—Ç–æ—Ä–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ—Å–ª–µ —Ç–∞–π–º–∞—É—Ç–∞
                            }
                            readyCheckTimeout = null; // –°–±—Ä–æ—Å–∏—Ç—å —Ç–∞–π–º–∞—É—Ç
                        }, 5000); // 5 —Å–µ–∫—É–Ω–¥, –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å (–Ω–∞–ø—Ä–∏–º–µ—Ä, 10 —Å–µ–∫—É–Ω–¥)
                    }

                } else {
                    // –ï—Å–ª–∏ –∫—Ç–æ-—Ç–æ –Ω–µ –≥–æ—Ç–æ–≤, –∏–ª–∏ –∏–∑–º–µ–Ω–∏–ª —Å—Ç–∞—Ç—É—Å, –æ—á–∏—â–∞–µ–º —Ç–∞–π–º–∞—É—Ç
                    if (readyCheckTimeout) {
                        clearTimeout(readyCheckTimeout);
                        readyCheckTimeout = null;
                    }
                }
            }

            function startGameLogic() {
                if(Game.isRunning)return; 
                Game.placing=false; 
                Game.isRunning=true;
                readinessCheckDiv.style.display='none'; 
                playerReadyBtn.style.display='none';
                document.querySelectorAll(".type-buttons").forEach(b=>b.style.pointerEvents="none");
                // Clear any pending timeout when game actually starts
                if (readyCheckTimeout) {
                    clearTimeout(readyCheckTimeout);
                    readyCheckTimeout = null;
                }
                // Ensure game loop starts only once
                if (!Game.loop) {
                    Game.loop = requestAnimationFrame(Game.gameLoop);
                }
                Game.ui.updateUI();
            }

            restartGameBtn.addEventListener("click", () => {
                // Client no longer alerts, just sends request to host
                sendMessageP2P("request_restart_game", null); 
                // Client also immediately restarts its local state for responsiveness
                restartGameLogic();
            });

            function restartGameLogic() {
                if(Game.loop)cancelAnimationFrame(Game.loop);
                Game.loop = null; // Reset loop reference
                Game.isRunning=false; 
                Game.units=[]; 
                Game.targetUnitsState = []; 
                Game.placing=true; 
                Game.winnerText=""; 
                Game.winnerPlayer=null;
                Game.localPlayerReady = false; // Set local readiness to false
                Game.remotePlayerReady = false; // Set remote readiness to false

                // Clear any pending timeout
                if (readyCheckTimeout) {
                    clearTimeout(readyCheckTimeout);
                    readyCheckTimeout = null;
                }

                if(Game.dataChannel && Game.dataChannel.readyState === 'open'){
                    readinessCheckDiv.style.display = 'block';
                    localReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤—ã'; // Explicitly set client's local readiness to "–ù–µ –≥–æ—Ç–æ–≤—ã"
                    remoteReadyStatusSpan.textContent = '–ù–µ –≥–æ—Ç–æ–≤';
                    playerReadyBtn.textContent = "–ì–æ—Ç–æ–≤ –∫ –∏–≥—Ä–µ"; 
                    playerReadyBtn.style.display = 'inline-block'; 
                    // playerReadyBtn.disabled = false; removed disable
                    canvas.style.pointerEvents = "auto";
                    document.getElementById("restartGameBtn").style.display = "none"; // Hide restart button
                    document.querySelectorAll(".type-buttons").forEach(c => c.style.pointerEvents = "auto"); // Re-enable unit type selection
                    Game.ui.updateUI();
                } else {
                    if (!resetP2PStateAndUI.isResetting) resetP2PStateAndUI(true,"–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –ø–æ—Ç–µ—Ä—è–Ω–æ. –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É.");
                    return;
                }
                Game.draw();
                if (Game.isHost) {
                    // Host should also broadcast the reset state to the client
                    sendMessageP2P("game_state_update", {
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })),
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer,
                        isRunning: Game.isRunning,
                        placing: Game.placing,
                        gameReset: true // <--- NEW: Signal to client that a game reset occurred
                    });
                }
            }
            
            Game.draw = function() {
                ctx.clearRect(0,0,Game.WIDTH,Game.HEIGHT); const gs=20; ctx.strokeStyle='rgba(128,128,128,0.2)';ctx.lineWidth=1;
                for(let x=0;x<=Game.WIDTH;x+=gs){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,Game.HEIGHT);ctx.stroke();}
                for(let y=0;y<=Game.HEIGHT;y+=gs){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(Game.WIDTH,y);ctx.stroke();}
                for(let u of Game.units)u.draw(ctx);
                if(Game.winnerText){
                    const cx=Game.WIDTH/2,cy=Game.HEIGHT/2; ctx.fillStyle="rgba(0,0,0,0.7)";ctx.fillRect(cx-150,cy-40,300,80);
                    ctx.textAlign="center";ctx.textBaseline="middle";ctx.font="bold 32px Arial";
                    if(Game.winnerPlayer==="player1"){ctx.fillStyle=Game.COLORS.player1;ctx.shadowColor="#00BFFF";}
                    else if(Game.winnerPlayer==="player2"){ctx.fillStyle=Game.COLORS.player2;ctx.shadowColor="#FF4500";}
                    else{ctx.fillStyle="white";ctx.shadowColor="white";}
                    ctx.shadowBlur=20;ctx.fillText(Game.winnerText,cx,cy);ctx.shadowBlur=0;
                }
            };
            Game.gameLoop = function() {
                // Only host updates the game state
                if (Game.isHost) {
                    Game.update();
                } else { // Client updates its units based on received targetUnitsState
                    // If game has ended for client, no need to interpolate, just display the final state
                    if (!Game.isRunning && Game.winnerText) {
                        // Client just draws the final state received
                        // No interpolation needed if game is over
                    } else {
                        // Create a new array for next Game.units state based on targetUnitsState
                        const nextUnits = [];

                        Game.targetUnitsState.forEach(targetUnitData => {
                            let currentUnit = Game.units.find(u => u.id === targetUnitData.id);

                            if (currentUnit) {
                                // Interpolate existing unit's position, accounting for wrapping around edges
                                let dx = targetUnitData.x - currentUnit.x;
                                if (Math.abs(dx) > Game.WIDTH / 2) {
                                    dx -= Math.sign(dx) * Game.WIDTH; // Adjust for wrapping
                                }
                                currentUnit.x = (currentUnit.x + dx * Game.interpolationFactor + Game.WIDTH) % Game.WIDTH;

                                let dy = targetUnitData.y - currentUnit.y;
                                if (Math.abs(dy) > Game.HEIGHT / 2) {
                                    dy -= Math.sign(dy) * Game.HEIGHT; // Adjust for wrapping
                                }
                                currentUnit.y = (currentUnit.y + dy * Game.interpolationFactor + Game.HEIGHT) % Game.HEIGHT;
                                currentUnit.type = targetUnitData.type; // Update type and player immediately
                                currentUnit.player = targetUnitData.player;
                            } else {
                                // New unit: create it at the target position.
                                currentUnit = new Game.Unit(targetUnitData.x, targetUnitData.y, targetUnitData.type, targetUnitData.player, targetUnitData.id);
                            }
                            nextUnits.push(currentUnit);
                        });

                        Game.units = nextUnits; // Update client's actual units array
                    }
                }
                // Both host and client draw the current game state
                Game.draw();
                // Loop continues if game is running or if we are placing and need to sync
                if ((Game.isRunning && !Game.winnerText) || Game.placing) {
                    Game.loop = requestAnimationFrame(Game.gameLoop);
                } else {
                    Game.isRunning = false; // Ensure isRunning is false if game loop stops
                    // If game has ended, clear the loop to prevent further calls
                    if (Game.loop) {
                        cancelAnimationFrame(Game.loop);
                        Game.loop = null;
                    }
                }
            };
            
            function handleCanvasInteraction(clientX, clientY) {
                if (!Game.placing || !Game.dataChannel || Game.dataChannel.readyState !== 'open') return;
                const rect=canvas.getBoundingClientRect(),sX=canvas.width/rect.width,sY=canvas.height/rect.height,x=(clientX-rect.left)*sX,y=(clientY-rect.top)*sY;
                let clickedUnitIdToRemove = null;
                const currentPlayerRole = Game.isHost ? "player1" : "player2";

                // Find if a unit at the click location belongs to the current player
                for(let i=Game.units.length-1;i>=0;i--){
                    const u=Game.units[i];
                    const dx=u.x-x,dy=u.y-y;
                    if(Math.hypot(dx,dy)<=15){
                        if (u.player === currentPlayerRole) {
                            clickedUnitIdToRemove = u.id;
                            break;
                        } else {
                            // If clicked on opponent's unit, do nothing.
                            return;
                        }
                    }
                }

                if (Game.isHost) { // If host, directly modify units and broadcast
                    if (clickedUnitIdToRemove) {
                        Game.units = Game.units.filter(u => u.id !== clickedUnitIdToRemove);
                    } else {
                        const type = Game.selectedTypes[currentPlayerRole], newU = new Game.Unit(x, y, type, currentPlayerRole);
                        Game.units.push(newU);
                    }
                    // Host's targetUnitsState is always its Game.units
                    Game.targetUnitsState = Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player }));

                    Game.ui.updateUI(); // Update host's UI immediately
                    Game.draw(); // Explicitly redraw for host's local unit placement
                    sendMessageP2P("game_state_update", { // Force broadcast after placement
                        units: Game.units.map(u => ({ id: u.id, x: u.x, y: u.y, type: u.type, player: u.player })), // Send serializable data
                        winnerText: Game.winnerText,
                        winnerPlayer: Game.winnerPlayer,
                        isRunning: Game.isRunning,
                        placing: Game.placing
                    });
                } else { // If client, send request to host
                    if (clickedUnitIdToRemove) {
                        sendMessageP2P("unit_placement_request", { player: currentPlayerRole, unitIdToRemove: clickedUnitIdToRemove });
                        // Local removal for immediate feedback
                        Game.units = Game.units.filter(u => u.id !== clickedUnitIdToRemove);
                        // Also remove from targetUnitsState for client's immediate display
                        Game.targetUnitsState = Game.targetUnitsState.filter(u => u.id !== clickedUnitIdToRemove);

                    } else {
                        const type = Game.selectedTypes[currentPlayerRole];
                        const newId = Math.random().toString(36).substr(2, 9); // Generate ID locally for immediate use
                        sendMessageP2P("unit_placement_request", { player: currentPlayerRole, x: x, y: y, unitId: newId });
                        // Local addition for immediate feedback
                        const newU = new Game.Unit(x, y, type, currentPlayerRole, newId);
                        Game.units.push(newU);
                        // Also add to targetUnitsState for smooth interpolation as soon as state update arrives
                        Game.targetUnitsState.push({ id: newU.id, x: newU.x, y: newU.y, type: newU.type, player: newU.player });
                    }
                    Game.ui.updateUI(); // Update client's UI
                    Game.draw(); // Force a draw on the client immediately
                }
            }
            canvas.addEventListener("click", e => handleCanvasInteraction(e.clientX, e.clientY));
            canvas.addEventListener("touchstart", e => { if(!Game.placing)return; e.preventDefault(); handleCanvasInteraction(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

            Game.ui.setupTypeButtons();
            resetP2PStateAndUI(false);
            Game.draw();
        });
    </script>
</body>
</html>
