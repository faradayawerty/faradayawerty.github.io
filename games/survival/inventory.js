let ITEM_DATA = {
	[ITEM_GREEN_GUN]: {
		name: "Acid Leech",
		desc: "Infinite toxic payload fueled by your own energy reserves.",
		name_rus: "Кислотная пиявка",
		desc_rus: "Бесконечный запас токсинов, работающий напрямую от вашей энергии."
	},
	[ITEM_SHIELD_GREEN]: {
		name: "Kinetic Barrier",
		desc: "Reinforced field that absorbs high-impact energy.",
		name_rus: "Кинетический барьер",
		desc_rus: "Усиленное поле, поглощающее энергию сильных ударов."
	},
	[ITEM_ROCKET_LAUNCHER]: {
		name: "Seeker Launcher",
		desc: "Fires high-velocity homing projectiles.",
		name_rus: "Установка «Ищейка»",
		desc_rus: "Выпускает высокоскоростные самонаводящиеся снаряды."
	},
	[ITEM_ROCKET_SHOTGUN]: {
		name: "Homing Flak",
		desc: "Spreads micro-missiles that lock onto nearby heat signatures.",
		name_rus: "Самонаводящаяся дробь",
		desc_rus: "Разбрасывает микро-ракеты, захватывающие тепловые сигнатуры."
	},
	[ITEM_GUN]: {
		name: "Pistol",
		desc: "Standard 9mm handgun.",
		name_rus: "Пистолет",
		desc_rus: "Стандартный 9-мм пистолет."
	},
	[ITEM_SHOTGUN]: {
		name: "Shotgun",
		desc: "Powerful close-range weapon.",
		name_rus: "Дробовик",
		desc_rus: "Мощное оружие для ближнего боя."
	},
	[ITEM_MINIGUN]: {
		name: "Minigun",
		desc: "Extremely high fire rate.",
		name_rus: "Миниган",
		desc_rus: "Экстремально высокая скорострельность."
	},
	[ITEM_PLASMA_LAUNCHER]: {
		name: "Plasma Launcher",
		desc: "Fires unstable plasma spheres.",
		name_rus: "Плазмомет",
		desc_rus: "Стреляет нестабильными сферами плазмы."
	},
	[ITEM_RED_PISTOLS]: {
		name: "Red Pistols",
		desc: "Dual pistols with increased damage.",
		name_rus: "Красные пистолеты",
		desc_rus: "Парные пистолеты с повышенным уроном."
	},
	[ITEM_RED_SHOTGUN]: {
		name: "Red Shotgun",
		desc: "Enhanced model with tighter spread.",
		name_rus: "Красный дробовик",
		desc_rus: "Улучшенная модель с кучной стрельбой."
	},
	[ITEM_RAINBOW_PISTOLS]: {
		name: "Rainbow Pistols",
		desc: "Chaos in every shot.",
		name_rus: "Радужные пистолеты",
		desc_rus: "Хаос в каждом выстреле."
	},
	[ITEM_LASER_GUN]: {
		name: "Laser Gun",
		desc: "High-precision energy beam.",
		name_rus: "Лазерная пушка",
		desc_rus: "Высокоточный энергетический луч."
	},
	[ITEM_PLASMA_PISTOL]: {
		name: "Plasma Pistol",
		desc: "Compact plasma firing sidearm.",
		name_rus: "Плазменный пистолет",
		desc_rus: "Компактное плазменное оружие."
	},
	[ITEM_JUNK_CANNON]: {
		name: "Junk Cannon",
		desc: "Turns trash into lethal projectiles.",
		name_rus: "Хламотрон",
		desc_rus: "Превращает мусор в смертоносные снаряды."
	},

	// Ближний бой (ITEMS_MELEE)
	[ITEM_SWORD]: {
		name: "Sword",
		desc: "A blade for honorable combat.",
		name_rus: "Меч",
		desc_rus: "Лезвие для благородного боя."
	},
	[ITEM_HORN]: {
		name: "Horn",
		desc: "Sharp and sturdy. Don't ask where it's from.",
		name_rus: "Рог",
		desc_rus: "Острый и прочный. Не спрашивай, откуда он."
	},

	// Боеприпасы (ITEMS_AMMOS)
	[ITEM_AMMO]: {
		name: "Ammo",
		desc: "Standard bullets.",
		name_rus: "Патроны",
		desc_rus: "Стандартные пули."
	},
	[ITEM_PLASMA]: {
		name: "Plasma Cells",
		desc: "Energy source for plasma weapons.",
		name_rus: "Плазменные ячейки",
		desc_rus: "Источник энергии для плазменного оружия."
	},
	[ITEM_RED_PLASMA]: {
		name: "Red Plasma",
		desc: "Overcharged plasma energy.",
		name_rus: "Красная плазма",
		desc_rus: "Перегруженная плазменная энергия."
	},
	[ITEM_GREEN_AMMO]: {
		name: "Corrosive Ammo",
		desc: "Bullets filled with acid.",
		name_rus: "Кислотные пули",
		desc_rus: "Пули, наполненные кислотой."
	},
	[ITEM_ROCKET]: {
		name: "Rockets",
		desc: "Explosive projectiles.",
		name_rus: "Ракеты",
		desc_rus: "Взрывоопасные снаряды."
	},
	[ITEM_RAINBOW_AMMO]: {
		name: "Rainbow Core",
		desc: "Shifts elements unpredictably.",
		name_rus: "Радужное ядро",
		desc_rus: "Непредсказуемо меняет стихии."
	},

	// Ресурсы и выживание
	[ITEM_HEALTH]: {
		name: "Health Kit",
		desc: "Restores a portion of HP.",
		name_rus: "Аптечка",
		desc_rus: "Восстанавливает часть здоровья."
	},
	[ITEM_HEALTH_GREEN]: {
		name: "Advanced Medkit",
		desc: "Powerful regenerative chemicals.",
		name_rus: "Улучшенная аптечка",
		desc_rus: "Мощные регенерирующие химикаты."
	},
	[ITEM_FUEL]: {
		name: "Gasoline",
		desc: "Used to refuel vehicles.",
		name_rus: "Бензин",
		desc_rus: "Используется для заправки машин."
	},
	[ITEM_SHIELD]: {
		name: "Energy Shield",
		desc: "Provides temporary protection.",
		name_rus: "Энергетический щит",
		desc_rus: "Дает временную защиту."
	},
	[ITEM_SHIELD_RAINBOW]: {
		name: "Prismatic Shield",
		desc: "Maximum protection against all types.",
		name_rus: "Призматический щит",
		desc_rus: "Максимальная защита от всех типов урона."
	},
	[ITEM_MONEY]: {
		name: "Money",
		desc: "Can be used for trading.",
		name_rus: "Деньги",
		desc_rus: "Можно использовать для торговли."
	},
	[ITEM_BOSSIFIER]: {
		name: "Bossifier",
		desc: "Unleashes hidden potential. Use with caution.",
		name_rus: "Боссификатор",
		desc_rus: "Раскрывает скрытый потенциал. Использовать осторожно."
	},

	// Еда (ITEMS_FOODS)
	[ITEM_CANNED_MEAT]: {
		name: "Canned Meat",
		desc: "Nutritious and long-lasting.",
		name_rus: "Тушенка",
		desc_rus: "Питательно и долго хранится."
	},
	[ITEM_ORANGE]: {
		name: "Orange",
		desc: "Rich in Vitamin C.",
		name_rus: "Апельсин",
		desc_rus: "Богат витамином C."
	},
	[ITEM_APPLE]: {
		name: "Apple",
		desc: "A fresh, crunchy snack.",
		name_rus: "Яблоко",
		desc_rus: "Свежий и хрустящий перекус."
	},
	[ITEM_CHERRIES]: {
		name: "Cherries",
		desc: "Small but sweet.",
		name_rus: "Вишни",
		desc_rus: "Маленькие, но сладкие."
	},
	[ITEM_CHICKEN_LEG]: {
		name: "Chicken Leg",
		desc: "Fried to perfection.",
		name_rus: "Куриная ножка",
		desc_rus: "Идеально прожарена."
	},
	[ITEM_CHOCOLATE]: {
		name: "Chocolate",
		desc: "Quick energy boost.",
		name_rus: "Шоколад",
		desc_rus: "Быстрый заряд энергии."
	},

	// Напитки (ITEMS_DRINKS)
	[ITEM_WATER]: {
		name: "Water",
		desc: "Essential for survival.",
		name_rus: "Вода",
		desc_rus: "Необходима для выживания."
	},
	[ITEM_COLA]: {
		name: "Cola",
		desc: "Sugary and carbonated.",
		name_rus: "Кола",
		desc_rus: "Сладкая и газированная."
	},
	[ITEM_MILK]: {
		name: "Milk",
		desc: "Good for your bones.",
		name_rus: "Молоко",
		desc_rus: "Полезно для костей."
	},

	// Мусор (ITEMS_JUNK)
	[ITEM_APPLE_CORE]: {
		name: "Apple Core",
		desc: "Someone already ate the good part.",
		name_rus: "Огрызок",
		desc_rus: "Кто-то уже съел все вкусное."
	},
	[ITEM_FISH_BONE]: {
		name: "Fish Bone",
		desc: "Leftovers from a meal.",
		name_rus: "Рыбья кость",
		desc_rus: "Остатки чьего-то обеда."
	},
	[ITEM_EMPTY_BOTTLE]: {
		name: "Empty Bottle",
		desc: "Could be recycled or filled.",
		name_rus: "Пустая бутылка",
		desc_rus: "Можно переработать или наполнить."
	},
	[ITEM_TIN_CAN]: {
		name: "Tin Can",
		desc: "Sharp edges, be careful.",
		name_rus: "Консервная банка",
		desc_rus: "Острые края, будь осторожен."
	},
	[ITEM_OLD_SHOE]: {
		name: "Old Shoe",
		desc: "The sole is falling off.",
		name_rus: "Старый ботинок",
		desc_rus: "Подошва вот-зат отвалится."
	},
	[ITEM_BENT_FORK]: {
		name: "Bent Fork",
		desc: "Useless for eating.",
		name_rus: "Гнутая вилка",
		desc_rus: "Бесполезна для еды."
	},
	[ITEM_CRUMPLED_PAPER]: {
		name: "Crumpled Paper",
		desc: "Indecipherable scribbles.",
		name_rus: "Ком мятой бумаги",
		desc_rus: "Неразборчивые каракули."
	},
	[ITEM_DEAD_BATTERY]: {
		name: "Dead Battery",
		desc: "No power left in this one.",
		name_rus: "Севшая батарейка",
		desc_rus: "В ней не осталось энергии."
	}
};

function inventory_create(g, attached_to_object = null) {
	let inv = {
		slot_size: 80,
		cross_size: 40, // Размер кнопки закрытия
		iselected: -1,
		jselected: -1,
		items: [
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
			[0, 0, 0, 0, 0, 0, 0, 0, 0],
		],
		imove: -1,
		jmove: -1,
		attached_to_object: attached_to_object,
		animation_state: 0,
		_touch_lock: false // Вспомогательный флаг для фиксации одного клика по тачу
	};
	return game_gui_element_create(g, "inventory", inv, inventory_update, inventory_draw, inventory_destroy);
}

function inventory_destroy(inventory_element) {
	inventory_element.data.attached_to_object = null;
	inventory_element.destroyed = true;
}

function inventory_update(inventory_element, dt) {
	// 0. ПРОВЕРКИ СОСТОЯНИЯ
	if (inventory_element.data.attached_to_object.data.ai_controlled)
		inventory_element.shown = false;

	if (!inventory_element.shown) return;

	let inv = inventory_element.data;
	let game = inventory_element.game;
	let input = game.input;
	let scale = get_scale();
	let player_object = inv.attached_to_object;

	// Инициализация переменных памяти, если их еще нет в объекте
	if (inv.was_left_down === undefined) inv.was_left_down = false;
	if (inv.was_right_down === undefined) inv.was_right_down = false;

	let mx = input.mouse.x / scale;
	let my = input.mouse.y / scale;

	let is_clicked = false;
	let is_clicked_right = false;

	// 1. ОПРЕДЕЛЕНИЕ КЛИКА (БЕЗ ОБНУЛЕНИЯ ГЛОБАЛЬНОГО INPUT)
	if (game.mobile) {
		// Логика для мобильных устройств (через ID тача)
		let freeTouch = input.touch.find(t => t.id !== input.joystick.left.id && t.id !== input.joystick.right.id);
		if (freeTouch) {
			mx = freeTouch.x / scale;
			my = freeTouch.y / scale;
			if (inv.active_touch_id !== freeTouch.id) {
				inv.active_touch_id = freeTouch.id;
				is_clicked = true;
			}
		} else {
			inv.active_touch_id = null;
		}
	} else {
		// Логика для ПК: сравниваем текущее состояние с предыдущим кадром
		let current_left = input.mouse.leftButtonPressed;
		let current_right = input.mouse.rightButtonPressed;

		if (current_left && !inv.was_left_down) is_clicked = true;
		if (current_right && !inv.was_right_down) is_clicked_right = true;

		// Сохраняем состояние для следующего кадра
		inv.was_left_down = current_left;
		inv.was_right_down = current_right;
	}

	inv.last_active_mx = mx;
	inv.last_active_my = my;
	inv.animation_state += 0.02 * dt;

	// Параметры мобильных кнопок действий
	let btnW = 120,
		btnH = 50,
		gap = 20;
	let startY = 60 + (inv.slot_size * 1.05) * inv.items.length;
	let startX = 40;

	// 2. ПКМ НА ПК: Быстрый выброс выбранного ("висящего на курсоре") предмета
	if (!game.mobile && is_clicked_right) {
		if (inv.imove !== -1 && inv.jmove !== -1) {
			inventory_drop_item(inventory_element, inv.imove, inv.jmove);
			inv.imove = -1;
			inv.jmove = -1;
			return; // Прерываем, так как действие выполнено
		}
	}

	// 3. МОБИЛЬНЫЕ КНОПКИ ДЕЙСТВИЯ (USE / DROP)
	if (game.mobile && inv.imove !== -1 && is_clicked) {
		// Кнопка USE
		if (doRectsCollide(mx, my, 0, 0, startX, startY, btnW, btnH)) {
			let id = inv.items[inv.imove][inv.jmove];
			if (id > 0) {
				player_item_consume(player_object, id, false);
				if (inv.imove !== -1 && inv.items[inv.imove][inv.jmove] === 0) {
					inv.imove = -1;
					inv.jmove = -1;
				}
			}
			return;
		}
		// Кнопка DROP
		if (doRectsCollide(mx, my, 0, 0, startX + btnW + gap, startY, btnW, btnH)) {
			inventory_drop_item(inventory_element, inv.imove, inv.jmove);
			inv.imove = -1;
			inv.jmove = -1;
			return;
		}
	}

	// 4. КНОПКА ЗАКРЫТИЯ (Крестик)
	let cross_x = 40 + (inv.slot_size * 1.05) * inv.items[0].length + 15;
	if (is_clicked && doRectsCollide(mx, my, 0, 0, cross_x, 40, inv.cross_size, inv.cross_size)) {
		inventory_element.shown = false;
		inv.imove = -1;
		inv.jmove = -1;
		return;
	}

	// 5. ЛОГИКА СЛОТОВ
	let slot_hit = false;
	for (let i = 0; i < inv.items.length; i++) {
		for (let j = 0; j < inv.items[i].length; j++) {
			let sx = 40 + (inv.slot_size * 1.05) * j;
			let sy = 40 + (inv.slot_size * 1.05) * i;

			if (doRectsCollide(mx, my, 0, 0, sx, sy, inv.slot_size, inv.slot_size)) {
				slot_hit = true;
				inv.iselected = i;
				inv.jselected = j;

				// ЛКМ (или основной тач) по слоту
				if (is_clicked) {
					if (inv.imove === -1) {
						// Если ничего не несем — берем предмет
						if (inv.items[i][j] > 0) {
							inv.imove = i;
							inv.jmove = j;
						}
					} else {
						// Если предмет в руках
						if (inv.imove === i && inv.jmove === j) {
							// Клик по тому же слоту — отмена выбора
							inv.imove = -1;
							inv.jmove = -1;
						} else {
							// Обмен предметами между слотами
							let temp = inv.items[i][j];
							inv.items[i][j] = inv.items[inv.imove][inv.jmove];
							inv.items[inv.imove][inv.jmove] = temp;
							inv.imove = -1;
							inv.jmove = -1;
						}
					}
				}

				// ПКМ по слоту на ПК — мгновенный выброс
				if (!game.mobile && is_clicked_right && inv.items[i][j] > 0) {
					inventory_drop_item(inventory_element, i, j);
					// Если выбрасываем тот предмет, который «несли», сбрасываем выделение
					if (inv.imove === i && inv.jmove === j) {
						inv.imove = -1;
						inv.jmove = -1;
					}
				}
			}
		}
	}

	if (!slot_hit) {
		inv.iselected = -1;
		inv.jselected = -1;
	}

	// 6. ГОРЯЧАЯ КЛАВИША Q (Выбросить)
	if (isKeyDown(input, 'q', true) || isKeyDown(input, 'й', true)) {
		let dI = (inv.imove !== -1) ? inv.imove : inv.iselected;
		let dJ = (inv.jmove !== -1) ? inv.jmove : inv.jselected;
		if (dI !== -1 && dJ !== -1 && inv.items[dI][dJ] > 0) {
			inventory_drop_item(inventory_element, dI, dJ);
			if (dI === inv.imove) {
				inv.imove = -1;
				inv.jmove = -1;
			}
		}
	}
}


function inventory_draw(inventory_element, ctx) {
	if (inventory_element.game.want_hide_inventory || !inventory_element.shown)
		return;

	let inv = inventory_element.data;
	let game = inventory_element.game;

	// 1. Отрисовка слотов
	for (let i = 0; i < inv.items.length; i++) {
		for (let j = 0; j < inv.items[i].length; j++) {
			let sx = 40 + (inv.slot_size * 1.05) * j;
			let sy = 40 + (inv.slot_size * 1.05) * i;

			ctx.globalAlpha = 0.9;
			if (inv.imove === i && inv.jmove === j)
				ctx.fillStyle = "orange"; // Выбранный предмет
			else if (inv.iselected === i && inv.jselected === j)
				ctx.fillStyle = "cyan"; // Наведенная мышь/палец
			else
				ctx.fillStyle = "blue";

			ctx.fillRect(sx, sy, inv.slot_size, inv.slot_size);
			ctx.globalAlpha = 1.0;

			// На ПК не рисуем иконку в слоте, если мы её "тащим" (она рисуется у мыши)
			// На мобилках imove — это просто выбор, поэтому иконка остается в слоте
			if (game.mobile || !(inv.imove === i && inv.jmove === j)) {
				item_icon_draw(ctx, inv.items[i][j], sx, sy, inv.slot_size, inv.slot_size, inv.animation_state);
			}
		}
	}

	// 2. Отрисовка кнопок USE/DROP для мобилок
	if (game.mobile && inv.imove !== -1) {
		let btnW = 120,
			btnH = 50,
			gap = 20;
		let startY = 60 + (inv.slot_size * 1.05) * inv.items.length;
		let startX = 40;

		const drawStyledBtn = (x, y, w, h, text, color) => {
			ctx.fillStyle = color;
			ctx.beginPath();
			if (ctx.roundRect) ctx.roundRect(x, y, w, h, 8);
			else ctx.fillRect(x, y, w, h);
			ctx.fill();
			ctx.strokeStyle = "white";
			ctx.lineWidth = 2;
			ctx.stroke();

			ctx.fillStyle = "white";
			ctx.font = "bold 18px Arial";
			ctx.textAlign = "center";
			ctx.fillText(text, x + w / 2, y + h / 2 + 6);
		};

		drawStyledBtn(startX, startY, btnW, btnH, "USE", "#228822");
		drawStyledBtn(startX + btnW + gap, startY, btnW, btnH, "DROP", "#882222");
	}

	// 3. Кнопка закрытия
	let cross_x = 40 + (inv.slot_size * 1.05) * inv.items[0].length + 15;
	let cross_y = 40;
	let cs = inv.cross_size;

	ctx.fillStyle = "#444444";
	ctx.fillRect(cross_x, cross_y, cs, cs);
	ctx.strokeStyle = "white";
	ctx.lineWidth = 2;
	ctx.strokeRect(cross_x, cross_y, cs, cs);
	ctx.beginPath();
	ctx.moveTo(cross_x + cs * 0.25, cross_y + cs * 0.25);
	ctx.lineTo(cross_x + cs * 0.75, cross_y + cs * 0.75);
	ctx.moveTo(cross_x + cs * 0.75, cross_y + cs * 0.25);
	ctx.lineTo(cross_x + cs * 0.25, cross_y + cs * 0.75);
	ctx.stroke();

	// 4. Предмет в руках (только для ПК при Drag-and-Drop)
	if (!game.mobile && inv.imove > -1 && inv.jmove > -1) {
		let curX = inv.last_active_mx || 0;
		let curY = inv.last_active_my || 0;
		let drag_size = inv.slot_size * 0.8;
		ctx.globalAlpha = 0.8;
		item_icon_draw(ctx, inv.items[inv.imove][inv.jmove], curX - drag_size / 2, curY - drag_size / 2, drag_size, drag_size, inv.animation_state);
		ctx.globalAlpha = 1.0;
	}

	// 5. Отрисовка подсказки (Tooltip)
	// Рисуем в самом конце, чтобы подсказка была ПОВЕРХ всего инвентаря
	if (inv.iselected !== -1 && inv.jselected !== -1) {
		let item_id = inv.items[inv.iselected][inv.jselected];

		// Показываем только если в слоте есть предмет и мы его сейчас не тащим (на ПК)
		if (item_id > 0 && (game.mobile || inv.imove === -1)) {
			let tooltipX = inv.last_active_mx + 20;
			let tooltipY = inv.last_active_my + 20;
			if (game.mobile) {
				tooltipX += 80;
				tooltipY += 80;
			}
			inventory_draw_item_popup(ctx, game, item_id, tooltipX, tooltipY);
		}
	}
}



function inventory_drop_item(inventory_element, i, j, death = false) {
	if (!inventory_element.data.attached_to_object || !inventory_element.data.attached_to_object.data.body)
		return;
	if (i < 0 || j < 0)
		return;
	if (inventory_element.data.items[i][j] == 0)
		return;
	item_create(inventory_element.game, inventory_element.data.items[i][j],
		inventory_element.data.attached_to_object.data.body.position.x + 100 * Math.cos(2 * Math.PI * Math.random()),
		inventory_element.data.attached_to_object.data.body.position.y + 100 * Math.sin(2 * Math.PI * Math.random()), !death, !death);
	inventory_element.data.items[i][j] = 0;
}

function inventory_drop_all_items(inventory_element) {
	for (let i = 0; i < inventory_element.data.items.length; i++)
		for (let j = 0; j < inventory_element.data.items[i].length; j++)
			inventory_drop_item(inventory_element, i, j, true);
}

// --- ХОТБАР ---

function hotbar_create(g, inv, attached_to_object = null) {
	let hb = {
		iselected: 0,
		row: inv.items[0],
		slot_size: 50,
		attached_to_object: attached_to_object,
		animation_state: 0,
		mouse_over: false
	};
	let ihotbar = game_gui_element_create(g, "hotbar", hb, hotbar_update, hotbar_draw, hotbar_destroy);
	g.gui_elements[ihotbar].shown = true;
	return ihotbar;
}

function hotbar_destroy(hotbar_element) {
	hotbar_element.data.attached_to_object = null;
	hotbar_element.destroyed = true;
}

function hotbar_update(hotbar_element, dt) {
	let hb = hotbar_element.data;
	let input = hotbar_element.game.input;
	let scale = get_scale();
	hb.animation_state += 0.02 * dt;

	if (hb.attached_to_object.data.ai_controlled)
		hotbar_element.shown = false;

	// Клавиши 1-9 (оставляем как есть)
	for (let i = 0; i < 9; i++) {
		if (isKeyDown(input, (i + 1).toString(), true)) hb.iselected = i;
	}

	if (isMouseWheelUp(input)) hb.iselected = (hb.iselected + 1) % 9;
	if (isMouseWheelDown(input)) hb.iselected = (hb.iselected - 1 + 9) % 9;

	hb.mouse_over = false;

	// --- ИСПРАВЛЕНИЕ МУЛЬТИТАЧА ---
	// Создаем список координат для проверки (мышь + все пальцы)
	let pointsToCheck = [];
	if (!isScreenTouched(input)) {
		pointsToCheck.push({
			x: input.mouse.x / scale,
			y: input.mouse.y / scale
		});
	} else {
		for (let t of input.touch) {
			pointsToCheck.push({
				x: t.x / scale,
				y: t.y / scale
			});
		}
	}

	// Проверяем каждую точку (палец или мышь) на попадание в слоты
	for (let pt of pointsToCheck) {
		for (let i = 0; i < hb.row.length; i++) {
			let sx = 40 + (hb.slot_size * 1.05) * i;
			let sy = 40;
			if ((hotbar_element.game.mobile || input.mouse.leftButtonPressed) && doRectsCollide(pt.x, pt.y, 0, 0, sx, sy, hb.slot_size, hb.slot_size)) {
				hb.mouse_over = true;
				hb.iselected = i; // Выбираем слот
			}
		}

		// Проверка мобильных кнопок (Инвентарь, Ачивки, Меню)
		if (hotbar_element.game.mobile) {
			let step = hb.slot_size * 1.05;
			let x_inv = 60 + step * hb.row.length;

			// Проверка кнопки сумки
			if (doRectsCollide(pt.x, pt.y, 0, 0, x_inv, 40, hb.slot_size, hb.slot_size)) {
				let inv_el = hb.attached_to_object.data.inventory_element;
				if (inv_el && !inv_el._mob_toggle_lock) {
					inv_el.shown = !inv_el.shown;
					inv_el._mob_toggle_lock = true;
				}
			}
		}
	}

	// Сброс лока переключения, если ни один палец не касается кнопок
	let inv_el = hb.attached_to_object.data.inventory_element;
	if (inv_el && inv_el._mob_toggle_lock) {
		let stillTouching = false;
		let step = hb.slot_size * 1.05;
		let x_inv = 60 + step * hb.row.length;
		for (let pt of pointsToCheck) {
			if (doRectsCollide(pt.x, pt.y, 0, 0, x_inv, 40, hb.slot_size, hb.slot_size)) stillTouching = true;
		}
		if (!stillTouching) inv_el._mob_toggle_lock = false;
	}
}

function hotbar_draw(hotbar_object, ctx) {
	let hb = hotbar_object.data;
	for (let i = 0; i < hb.row.length; i++) {
		ctx.globalAlpha = 0.9;
		ctx.fillStyle = (hb.iselected == i) ? "cyan" : "blue";
		ctx.fillRect(40 + (hb.slot_size * 1.05) * i, 40, hb.slot_size, hb.slot_size);
		ctx.globalAlpha = 1.0;
		item_icon_draw(ctx, hb.row[i], 40 + (hb.slot_size * 1.05) * i, 40, hb.slot_size, hb.slot_size, hb.animation_state);
	}

	if (hotbar_object.game.mobile) {
		let s = hb.slot_size;
		let step = s * 1.05;
		let y = 40;

		// Функция-помощник для отрисовки фона кнопки (внутри hotbar_draw)
		const drawButtonBg = (x) => {
			ctx.fillStyle = "#4477ff";
			ctx.globalAlpha = 0.9;
			ctx.fillRect(x, y, s, s);
			ctx.globalAlpha = 1.0;
		};

		// --- 1. КНОПКА ИНВЕНТАРЯ (Портфель) ---
		let x_inv = 60 + step * hb.row.length;
		drawButtonBg(x_inv);

		let pad = s * 0.2;
		let bw = s - pad * 2;
		let bh = s - pad * 2;
		let bx = x_inv + pad;
		let by = y + pad;

		ctx.fillStyle = "#a52a2a";
		ctx.fillRect(bx, by + bh * 0.2, bw, bh * 0.8);
		ctx.fillStyle = "#8b4513";
		ctx.fillRect(bx, by + bh * 0.1, bw, bh * 0.4);
		ctx.strokeStyle = "#8b4513";
		ctx.lineWidth = s * 0.05;
		ctx.beginPath();
		ctx.arc(bx + bw / 2, by + bh * 0.1, bw * 0.2, Math.PI, 0);
		ctx.stroke();
		ctx.fillStyle = "yellow";
		ctx.fillRect(bx + bw * 0.2, by + bh * 0.4, bw * 0.1, bh * 0.2);
		ctx.fillRect(bx + bw * 0.7, by + bh * 0.4, bw * 0.1, bh * 0.2);
		ctx.strokeStyle = "black";
		ctx.lineWidth = s * 0.02;
		ctx.strokeRect(bx, by + bh * 0.2, bw, bh * 0.8);

		// --- 2. КНОПКА АЧИВОК (Кубок) ---
		let x_ach = x_inv + step;
		drawButtonBg(x_ach);

		let ax = x_ach + s * 0.25;
		let ay = y + s * 0.25;
		let aw = s * 0.5;
		let ah = s * 0.5;

		ctx.fillStyle = "gold";
		ctx.beginPath();
		ctx.moveTo(ax, ay);
		ctx.lineTo(ax + aw, ay);
		ctx.lineTo(ax + aw * 0.8, ay + ah * 0.6);
		ctx.lineTo(ax + aw * 0.2, ay + ah * 0.6);
		ctx.closePath();
		ctx.fill();
		ctx.strokeStyle = "orange";
		ctx.lineWidth = s * 0.03;
		ctx.stroke();
		ctx.fillRect(ax + aw * 0.4, ay + ah * 0.6, aw * 0.2, ah * 0.3);
		ctx.fillRect(ax + aw * 0.2, ay + ah * 0.8, aw * 0.6, ah * 0.2);
		ctx.beginPath();
		ctx.arc(ax, ay + ah * 0.3, s * 0.1, 0, Math.PI * 2);
		ctx.arc(ax + aw, ay + ah * 0.3, s * 0.1, 0, Math.PI * 2);
		ctx.stroke();

		// --- 3. КНОПКА МЕНЮ (Три полоски / Бургер) ---
		let x_menu = x_ach + step;
		drawButtonBg(x_menu);

		ctx.fillStyle = "white";
		let barW = s * 0.5; // Длина полоски
		let barH = s * 0.08; // Толщина полоски
		let barX = x_menu + (s - barW) / 2; // Центрируем по горизонтали

		// Рисуем три полоски
		ctx.fillRect(barX, y + s * 0.3, barW, barH);
		ctx.fillRect(barX, y + s * 0.48, barW, barH);
		ctx.fillRect(barX, y + s * 0.66, barW, barH);

		// Добавим легкую тень для объема
		ctx.fillStyle = "rgba(0,0,0,0.3)";
		ctx.fillRect(barX, y + s * 0.3 + barH, barW, barH * 0.3);
	}
}

// --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---

function hotbar_get_selected_item(hotbar_element) {
	// На телефоне если инвентарь открыт, мы НЕ должны использовать предметы из хотбара кликом в мире
	let inv_el = hotbar_element.data.attached_to_object.data.inventory_element;
	if (inv_el.game.mobile && inv_el && inv_el.shown) return 0;

	if (!hotbar_element.shown) {
		if (hotbar_element.data.attached_to_object.name == "player" && !hotbar_element.data.attached_to_object.destroyed) {
			let inv = hotbar_element.data.attached_to_object.data.inventory_element.data;
			if (inv.jmove > -1 && inv.imove > -1) {
				if (inv.iselected == -1 && inv.jselected == -1)
					return inv.items[inv.imove][inv.jmove];
			}
		}
		return 0;
	} else if (hotbar_element.data.mouse_over) {
		return 0;
	}
	return hotbar_element.data.row[hotbar_element.data.iselected];
}

function inventory_has_item_from_list(inventory_element, item_ids) {
	for (let i = item_ids.length - 1; i >= 0; i--) {
		if (inventory_has_item(inventory_element, item_ids[i]))
			return item_ids[i];
	}
	return -1;
}

function inventory_has_item(inventory_element, id) {
	for (let i = 0; i < inventory_element.data.items.length; i++) {
		for (let j = 0; j < inventory_element.data.items[i].length; j++)
			if (inventory_element.data.items[i][j] == id)
				return true;
	}
	return false;
}

function inventory_count_item(inventory_element, id) {
	let ans = 0;
	for (let i = 0; i < inventory_element.data.items.length; i++) {
		for (let j = 0; j < inventory_element.data.items[i].length; j++)
			if (inventory_element.data.items[i][j] == id)
				ans++;
	}
	return ans;
}

function inventory_clear_item(inventory_element, id, count, item_i = -1, item_j = -1) {
	if (item_i == inventory_element.data.imove && item_j == inventory_element.data.jmove) {
		inventory_element.data.imove = -1;
		inventory_element.data.jmove = -1;
	}

	if (item_i > -1 && item_j > -1 && inventory_element.data.items[item_i][item_j] == id) {
		inventory_element.data.items[item_i][item_j] = 0;
		count--;
	}

	for (let i = 0; i < inventory_element.data.items.length && count > 0; i++)
		for (let j = 0; j < inventory_element.data.items[i].length && count > 0; j++)
			if (inventory_element.data.items[i][j] == id) {
				inventory_element.data.items[i][j] = 0;
				count--;
			}
}

function inventory_draw_item_popup(ctx, game, item_id, x, y) {
	let data = ITEM_DATA[item_id] || {
		name: "???",
		desc: "Unknown item",
		name_rus: "???",
		desc_rus: "Неизвестный предмет"
	};

	let isRus = game.settings.language === "русский";
	let name = isRus ? data.name_rus : data.name;
	let desc = isRus ? data.desc_rus : data.desc;

	let W = 350;
	let H = 150;
	let fontsize = 16;

	// Чтобы окно не уходило за край экрана
	let scale = get_scale();
	if (x + W > window.innerWidth / scale) x -= W;
	if (y + H > window.innerHeight / scale) y -= H;

	ctx.save();
	ctx.globalAlpha = 0.9;
	ctx.fillStyle = "black";
	ctx.strokeStyle = "gray";
	ctx.lineWidth = 2;

	// Рисуем рамку
	ctx.fillRect(x, y, W, H);
	ctx.strokeRect(x, y, W, H);

	// Заголовок
	ctx.globalAlpha = 1.0;
	ctx.fillStyle = "yellow";
	ctx.font = `bold ${fontsize + 2}px Arial`;
	ctx.textAlign = "left";
	ctx.fillText(name, x + 10, y + 25);

	// Описание с простейшим переносом
	ctx.fillStyle = "white";
	ctx.font = `${fontsize}px Arial`;

	let words = desc.split(' ');
	let line = "";
	let lineY = y + 50;
	for (let n = 0; n < words.length; n++) {
		let testLine = line + words[n] + " ";
		if (testLine.length > 30) {
			ctx.fillText(line, x + 10, lineY);
			line = words[n] + " ";
			lineY += fontsize * 1.2;
		} else {
			line = testLine;
		}
	}
	ctx.fillText(line, x + 10, lineY);
	ctx.restore();
}