
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Игра Пазл</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            transition: background-color 0.5s, color 0.5s;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            overflow: hidden;
        }

        /* Светлая тема */
        body.light-theme {
            background-color: #f7fafc;
            color: #2d3748;
        }

        .light-theme .bg-gray-800 {
            background-color: #e2e8f0;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        
        .light-theme .bg-gray-700, .light-theme button {
            background-color: #cbd5e0;
            color: #2d3748;
            border-color: #a0aec0;
        }

        .light-theme .text-gray-400 {
            color: #4a5568;
        }
        
        .light-theme .bg-gray-600 {
            background-color: #a0aec0;
            color: #2d3748;
        }

        /* Исправляем цвет текста статистики для светлой темы */
        .light-theme .stat-panel .text-white {
            color: #2d3748;
        }

        .light-theme canvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Устанавливаем размер холста, чтобы он был большим, квадратным и оставался в пределах экрана */
        #puzzleCanvas {
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
            transition: border-color 0.5s ease-in-out;
            touch-action: none;
            border: 4px solid #ef4444;
            /* Размеры в CSS для адаптивности */
            width: min(85vw, 85vh);
            height: min(85vw, 85vh);
        }

        .control-panel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            width: 100%;
            margin-bottom: 1rem;
            align-items: center; /* Центрируем элементы внутри панели управления */
        }
        
        @media (min-width: 768px) {
            .control-panel {
                width: auto;
                margin-right: 1.5rem;
                margin-bottom: 0;
            }
        }
        
        /* Выравниваем статистику по левому краю */
        .stat-panel {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: flex-start; /* Выравнивание по левому краю */
            margin-bottom: 0.5rem;
            text-align: left;
        }

        /* Стили для модального окна кадрирования */
        .modal {
            display: none; /* Скрыто по умолчанию */
            position: fixed;
            z-index: 20;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #2d3748;
            padding: 1.5rem;
            border-radius: 1rem;
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-shrink: 0; /* Добавлено для предотвращения переполнения */
        }
        
        /* Контейнер для изображения в модальном окне */
        #cropper-container {
            max-width: min(80vw, 80vh); /* Уменьшаем максимальный размер */
            max-height: min(80vw, 80vh); /* Уменьшаем максимальный размер */
        }

    </style>
</head>
<body class="bg-gray-900 flex items-center justify-center min-h-screen relative">

    <button id="themeSwitcher" class="fixed top-4 right-4 p-2 rounded-full bg-gray-700 text-white hover:bg-gray-600 transition duration-300 focus:outline-none focus:ring-2 focus:ring-blue-400 z-10">
        <svg id="moonIcon" class="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
        </svg>
        <svg id="sunIcon" class="w-6 h-6 hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
        </svg>
    </button>
    
    <div class="bg-gray-800 shadow-xl rounded-2xl p-6 md:p-8 text-center max-w-full flex flex-col md:flex-row items-center justify-center">

        <div class="control-panel">
            <div class="stat-panel text-gray-400 font-bold text-sm sm:text-lg">
                <p>Не на своём месте: <span id="outOfPlaceCount" class="text-white">0</span></p>
                <p>Ходы: <span id="movesCount" class="text-white">0</span></p>
                <p>Время: <span id="timer" class="text-white">00:00</span></p>
            </div>
            
            <div class="flex flex-col gap-2 w-full items-center">
                <select id="sizeSelector" class="p-2 text-sm rounded-full bg-gray-700 border border-gray-600 text-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-400 transition duration-300 w-full">
                    </select>
                <button id="shuffleButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg w-full">
                    Перемешать
                </button>
                <button id="selectImageButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg w-full">
                    Выбрать изображение
                </button>
                <input type="file" id="imageInput" accept="image/*" class="hidden">
                 <button id="solveButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg w-full">
                    Собрать
                </button>
                
                <div class="flex items-center gap-2 w-full">
                    <button id="modePrevButton" class="px-3 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg flex-grow-0">&lt;</button>
                    <span id="modeName" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 flex-grow text-center">Режим: Пятнашки</span>
                    <button id="modeNextButton" class="px-3 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg flex-grow-0">&gt;</button>
                </div>

                <button id="hintsButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg w-full">
                    Подсказки: Выкл.
                </button>

                <button id="animationsButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-offset-2 shadow-lg w-full">
                    Анимации: Вкл.
                </button>

                 <button id="resetStatsButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-600 hover:bg-gray-500 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-offset-2 shadow-lg w-full">
                    Сбросить статистику
                </button>
            </div>
        </div>

        <div class="flex-grow flex items-center justify-center">
            <canvas id="puzzleCanvas" class="max-w-full max-h-full"></canvas>
        </div>
        
    </div>

    <div id="croppingModal" class="modal">
        <div class="modal-content">
            <div id="cropper-container">
                <img id="cropper-image" src="" alt="Image to crop" class="max-w-full max-h-full">
            </div>
            <div class="flex gap-4 mt-2">
                <button id="cropButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-700 hover:bg-gray-600 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-700 focus:ring-ring-offset-2 shadow-lg">
                    Кадрировать
                </button>
                <button id="closeModalButton" class="px-4 py-2 text-sm text-white font-bold rounded-full bg-gray-600 hover:bg-gray-500 transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-gray-600 focus:ring-offset-2 shadow-lg">
                    Закрыть
                </button>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('puzzleCanvas');
            const ctx = canvas.getContext('2d');
            const sizeSelector = document.getElementById('sizeSelector');
            const shuffleButton = document.getElementById('shuffleButton');
            const selectImageButton = document.getElementById('selectImageButton');
            const imageInput = document.getElementById('imageInput');
            const solveButton = document.getElementById('solveButton');
            const hintsButton = document.getElementById('hintsButton');
            const resetStatsButton = document.getElementById('resetStatsButton');
            const themeSwitcher = document.getElementById('themeSwitcher');
            const moonIcon = document.getElementById('moonIcon');
            const sunIcon = document.getElementById('sunIcon');
            
            // Новые элементы для переключения режимов
            const modePrevButton = document.getElementById('modePrevButton');
            const modeNextButton = document.getElementById('modeNextButton');
            const modeNameElement = document.getElementById('modeName');
            
            // NEW ELEMENT: Animations toggle button
            const animationsButton = document.getElementById('animationsButton');

            // Элементы модального окна Cropper.js
            const croppingModal = document.getElementById('croppingModal');
            const cropperImage = document.getElementById('cropper-image');
            const cropButton = document.getElementById('cropButton');
            const closeModalButton = document.getElementById('closeModalButton');
            let cropper;

            // --- Элементы статистики ---
            const outOfPlaceCountElement = document.getElementById('outOfPlaceCount');
            const movesCountElement = document.getElementById('movesCount');
            const timerElement = document.getElementById('timer');

            // --- КОНФИГУРАЦИЯ ---
            let IMAGE_SRC = 'img.jpg'; 
            const ANIMATION_DURATION = 300; 

            // --- СОСТОЯНИЕ ИГРЫ ---
            let image = new Image();
            let gridSize = 3;
            let tileWidth, tileHeight;
            let tiles = [];
            let emptyTile = {};
            let isSolved = true;
            let showHints = false;
            let isAnimationsEnabled = true; // NEW STATE VARIABLE
            let gameMode = 'classic';
            const modes = ['classic', 'flips', 'flips+', 'rotations', 'rotations+'];
            const modeNames = {
                'classic': 'Пятнашки',
                'flips': 'Перевороты',
                'flips+': 'Перевороты+',
                'rotations': 'Повороты',
                'rotations+': 'Повороты+'
            };

            // Флаг для контроля основного цикла анимации
            let isAnimating = false;

            // --- Состояние статистики ---
            let movesCount = 0;
            let timerSeconds = 0;
            let timerInterval = null;

            // --- ИНИЦИАЛИЗАЦИЯ ---
            function setupGame() {
                for (let i = 2; i <= 16; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = `${i}x${i}`;
                    sizeSelector.appendChild(option);
                }
                sizeSelector.value = gridSize;
                
                image.onload = () => {
                    initPuzzle();
                    requestAnimationFrame(animateLoop);
                };
                image.src = IMAGE_SRC;

                window.addEventListener('resize', initPuzzle);
                applySavedTheme();
            }

            function initPuzzle() {
                movesCount = 0;
                timerSeconds = 0;
                stopTimer();
                isSolved = true;
                
                const minDim = Math.min(image.naturalWidth, image.naturalHeight);
                canvas.width = minDim;
                canvas.height = minDim;
                
                ctx.imageSmoothingEnabled = false;

                tileWidth = canvas.width / gridSize;
                tileHeight = canvas.height / gridSize;
                
                tiles = [];
                const tileCount = gridSize * gridSize;
                
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const tileIndex = row * gridSize + col;
                        if (gameMode === 'classic' && tileIndex >= tileCount - 1) {
                            emptyTile = { currentPos: { row: row, col: col } };
                        } else {
                            tiles.push({
                                originalIndex: tileIndex,
                                currentPos: { row: row, col: col },
                                isFlippedHorizontal: false,
                                isFlippedVertical: false,
                                rotation: 0,
                                isAnimating: false,
                                animationStartTime: 0,
                                startState: {},
                                endState: {},
                            });
                        }
                    }
                }
                
                updateStats();
                drawPuzzle();
                updateCanvasBorder();
            }

            // Функция для отрисовки стрелки
            function drawArrow(x, y, size, color) {
                ctx.fillStyle = color;
                ctx.font = `bold ${size}px Inter, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('↑', x, y);
            }

            function easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }

            function animateLoop(timestamp) {
                if (!isAnimationsEnabled) {
                     drawPuzzle();
                     return;
                }
                
                let isAnyAnimating = false;
                tiles.forEach(tile => {
                    if (tile.isAnimating) {
                        isAnyAnimating = true;
                        const elapsed = timestamp - tile.animationStartTime;
                        let progress = Math.min(elapsed / ANIMATION_DURATION, 1);
                        const easedProgress = easeInOutCubic(progress);

                        if (tile.animationType === 'slide') {
                            tile.currentPos.col = tile.startState.col + (tile.endState.col - tile.startState.col) * easedProgress;
                            tile.currentPos.row = tile.startState.row + (tile.endState.row - tile.startState.row) * easedProgress;
                        } else if (tile.animationType === 'rotate') {
                            tile.currentRotation = tile.startState.rotation + (tile.endState.rotation - tile.startState.rotation) * easedProgress;
                        } else if (tile.animationType === 'flip') {
                            const startScaleX = tile.startState.isFlippedHorizontal ? -1 : 1;
                            const endScaleX = tile.endState.isFlippedHorizontal ? -1 : 1;
                            const startScaleY = tile.startState.isFlippedVertical ? -1 : 1;
                            const endScaleY = tile.endState.isFlippedVertical ? -1 : 1;
                            
                            tile.currentScaleX = startScaleX + (endScaleX - startScaleX) * easedProgress;
                            tile.currentScaleY = startScaleY + (endScaleY - startScaleY) * easedProgress;
                        }

                        if (progress >= 1) {
                            if (tile.animationType === 'slide') {
                                tile.currentPos = { ...tile.endState };
                                const startPos = { ...tile.startState };
                                emptyTile.currentPos = { row: startPos.row, col: startPos.col };
                            } else if (tile.animationType === 'rotate') {
                                tile.rotation = (tile.endState.rotation % 360 + 360) % 360;
                            } else if (tile.animationType === 'flip') {
                                tile.isFlippedHorizontal = tile.endState.isFlippedHorizontal;
                                tile.isFlippedVertical = tile.endState.isFlippedVertical;
                            }
                            
                            tile.isAnimating = false;
                            checkWin();
                            updateStats();
                        }
                    }
                });

                drawPuzzle();
                requestAnimationFrame(animateLoop);
            }

            function drawPuzzle() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const minDim = Math.min(image.naturalWidth, image.naturalHeight);
                const sourceX = (image.naturalWidth - minDim) / 2;
                const sourceY = (image.naturalHeight - minDim) / 2;
                
                const sourceTileWidth = minDim / gridSize;
                const sourceTileHeight = minDim / gridSize;

                tiles.forEach(tile => {
                    drawSingleTile(tile, sourceX, sourceY, sourceTileWidth, sourceTileHeight);
                });
            }

            function drawSingleTile(tile, sourceX, sourceY, sourceTileWidth, sourceTileHeight) {
                const currentX = (tile.isAnimating ? tile.currentPos.col : tile.currentPos.col) * tileWidth;
                const currentY = (tile.isAnimating ? tile.currentPos.row : tile.currentPos.row) * tileHeight;
                
                let tileRotation = tile.isAnimating ? tile.currentRotation : tile.rotation;
                let tileScaleX = tile.isAnimating ? tile.currentScaleX : (tile.isFlippedHorizontal ? -1 : 1);
                let tileScaleY = tile.isAnimating ? tile.currentScaleY : (tile.isFlippedVertical ? -1 : 1);

                const originalRow = Math.floor(tile.originalIndex / gridSize);
                const originalCol = tile.originalIndex % gridSize;

                ctx.save();
                
                ctx.translate(currentX + tileWidth / 2, currentY + tileHeight / 2);
                ctx.rotate(tileRotation * Math.PI / 180);
                ctx.scale(tileScaleX, tileScaleY);

                ctx.drawImage(
                    image,
                    sourceX + originalCol * sourceTileWidth,
                    sourceY + originalRow * sourceTileHeight,
                    sourceTileWidth,
                    sourceTileHeight,
                    -tileWidth / 2,
                    -tileHeight / 2,
                    tileWidth,
                    tileHeight
                );

                ctx.restore();

                // Рисуем стрелки только в режимах поворота И только если включены подсказки
                if ((gameMode === 'rotations' || gameMode === 'rotations+') && showHints) {
                     ctx.save();
                     ctx.translate(currentX + tileWidth / 2, currentY + tileHeight / 2);
                     ctx.rotate(tileRotation * Math.PI / 180);
                     if (tile.isFlippedHorizontal) ctx.scale(-1, 1);
                     if (tile.isFlippedVertical) ctx.scale(1, -1);
                     drawArrow(0, 0, Math.max(12, Math.min(tileWidth, tileHeight) * 0.4), '#e0e0e0');
                     ctx.restore();
                }

                // Рисуем подсказки
                if (showHints) {
                    const solvedRow = Math.floor(tile.originalIndex / gridSize);
                    const solvedCol = tile.originalIndex % gridSize;
                    
                    const isCorrect = (tile.currentPos.row === solvedRow) && 
                                      (tile.currentPos.col === solvedCol) &&
                                      !tile.isFlippedHorizontal && !tile.isFlippedVertical &&
                                      tile.rotation === 0;

                    ctx.fillStyle = isCorrect ? 'rgba(34, 197, 94, 0.3)' : 'rgba(239, 68, 68, 0.3)';
                    ctx.fillRect(currentX, currentY, tileWidth, tileHeight);

                    const hintColor = isCorrect ? '#22c55e' : '#ef4444';
                    
                    if (gameMode === 'classic') {
                        ctx.fillStyle = hintColor;
                        const fontSize = Math.max(12, Math.min(tileWidth, tileHeight) * 0.4);
                        ctx.font = `bold ${fontSize}px Inter, sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(tile.originalIndex + 1, currentX + tileWidth / 2, currentY + tileHeight / 2);
                    } else if ((gameMode === 'rotations' || gameMode === 'rotations+') && showHints) {
                        ctx.save();
                        ctx.translate(currentX + tileWidth / 2, currentY + tileHeight / 2);
                        ctx.rotate(tileRotation * Math.PI / 180);
                        if (tile.isFlippedHorizontal) ctx.scale(-1, 1);
                        if (tile.isFlippedVertical) ctx.scale(1, -1);
                        drawArrow(0, 0, Math.max(12, Math.min(tileWidth, tileHeight) * 0.4), hintColor);
                        ctx.restore();
                    }
                }
                
                ctx.strokeStyle = '#334155';
                ctx.lineWidth = 1;
                ctx.strokeRect(currentX, currentY, tileWidth, tileHeight);
            }

            // Улучшенная функция перемешивания, которая гарантирует решаемость
            function shufflePuzzle() {
                initPuzzle();
                const movesToShuffle = gridSize * gridSize * 300; // Увеличиваем количество ходов
                
                for (let i = 0; i < movesToShuffle; i++) {
                    const randomRow = Math.floor(Math.random() * gridSize);
                    const randomCol = Math.floor(Math.random() * gridSize);
                    const randomTile = getTileByPosition(randomRow, randomCol);

                    if (!randomTile) continue;
                    
                    if (gameMode === 'classic') {
                         const movableTiles = getMovableTiles();
                         const randomMove = movableTiles[Math.floor(Math.random() * movableTiles.length)];
                         if (randomMove) {
                             swapTiles(randomMove.tile, randomMove.emptyPos);
                         }
                    } else if (gameMode === 'rotations') {
                        randomTile.rotation = (randomTile.rotation + 90) % 360;
                    } else if (gameMode === 'rotations+') {
                         applyToNeighbors(randomRow, randomCol, (neighbor) => {
                             neighbor.rotation = (neighbor.rotation + 90) % 360;
                         });
                    } else if (gameMode === 'flips') {
                        if (Math.random() > 0.5) {
                            randomTile.isFlippedHorizontal = !randomTile.isFlippedHorizontal;
                        } else {
                            randomTile.isFlippedVertical = !randomTile.isFlippedVertical;
                        }
                    } else if (gameMode === 'flips+') {
                         applyToNeighbors(randomRow, randomCol, (neighbor) => {
                             neighbor.isFlippedHorizontal = !neighbor.isFlippedHorizontal;
                         });
                    }
                }
                
                isSolved = false;
                movesCount = 0;
                timerSeconds = 0;
                startTimer();
                updateStats();
                drawPuzzle();
                updateCanvasBorder();
            }

            function getMovableTiles() {
                if (gameMode !== 'classic') return [];
                const movable = [];
                const emptyRow = emptyTile.currentPos.row;
                const emptyCol = emptyTile.currentPos.col;

                const possibleMoves = [
                    { row: emptyRow, col: emptyCol + 1 }, 
                    { row: emptyRow, col: emptyCol - 1 }, 
                    { row: emptyRow + 1, col: emptyCol }, 
                    { row: emptyRow - 1, col: emptyCol }, 
                ];

                possibleMoves.forEach(pos => {
                    if (pos.row >= 0 && pos.row < gridSize && pos.col >= 0 && pos.col < gridSize) {
                        const tileToMove = tiles.find(t => t.currentPos.row === pos.row && t.currentPos.col === pos.col);
                        if (tileToMove) {
                            movable.push({ tile: tileToMove, emptyPos: { row: emptyRow, col: emptyCol } });
                        }
                    }
                });
                return movable;
            }

            function swapTiles(tile, emptyPos) {
                const tempPos = { ...tile.currentPos };
                tile.currentPos = { ...emptyPos };
                emptyTile.currentPos = tempPos;
            }

            function checkWin() {
                let solved = true;
                
                for (let i = 0; i < tiles.length; i++) {
                    const tile = tiles[i];
                    const solvedRow = Math.floor(tile.originalIndex / gridSize);
                    const solvedCol = tile.originalIndex % gridSize;
                    
                    if (tile.currentPos.row !== solvedRow || 
                        tile.currentPos.col !== solvedCol ||
                        tile.isFlippedHorizontal ||
                        tile.isFlippedVertical ||
                        tile.rotation !== 0) {
                        solved = false;
                        break;
                    }
                }
                
                if (gameMode === 'classic') {
                    const emptySolvedRow = gridSize - 1;
                    const emptySolvedCol = gridSize - 1;
                    if (emptyTile.currentPos.row !== emptySolvedRow || emptyTile.currentPos.col !== emptySolvedCol) {
                        solved = false;
                    }
                }

                if (solved && !isSolved) {
                    stopTimer();
                }

                isSolved = solved;
                updateCanvasBorder();
            }

            function updateCanvasBorder() {
                if (isSolved) {
                    canvas.style.borderColor = '#22c55e'; // Зеленый
                } else {
                    canvas.style.borderColor = '#ef4444'; // Красный
                }
            }

            // --- ФУНКЦИИ СТАТИСТИКИ ---
            function checkOutOfPlaceTiles() {
                let count = 0;
                tiles.forEach(tile => {
                    const originalRow = Math.floor(tile.originalIndex / gridSize);
                    const originalCol = tile.originalIndex % gridSize;
                    
                    const isCorrect = (tile.currentPos.row === originalRow &&
                                       tile.currentPos.col === originalCol &&
                                       !tile.isFlippedHorizontal &&
                                       !tile.isFlippedVertical &&
                                       tile.rotation === 0);

                    if (!isCorrect) {
                        count++;
                    }
                });
                outOfPlaceCountElement.textContent = count;
            }

            function updateStats() {
                movesCountElement.textContent = movesCount;
                const minutes = Math.floor(timerSeconds / 60).toString().padStart(2, '0');
                const seconds = (timerSeconds % 60).toString().padStart(2, '0');
                timerElement.textContent = `${minutes}:${seconds}`;
                checkOutOfPlaceTiles();
            }

            function startTimer() {
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timerSeconds++;
                    updateStats();
                }, 1000);
            }

            function stopTimer() {
                if (timerInterval) {
                    clearInterval(timerInterval);
                    timerInterval = null;
                }
            }

            function resetStats() {
                movesCount = 0;
                timerSeconds = 0;
                updateStats();
            }

            // --- ФУНКЦИИ ТЕМЫ ---
            function toggleTheme() {
                document.body.classList.toggle('light-theme');
                const isLight = document.body.classList.contains('light-theme');
                moonIcon.classList.toggle('hidden', isLight);
                sunIcon.classList.toggle('hidden', !isLight);
            }

            function applySavedTheme() {
                // Логика для сохранения темы
            }
            
            // --- ОБРАБОТЧИКИ СОБЫТИЙ ---
            sizeSelector.addEventListener('change', () => {
                gridSize = parseInt(sizeSelector.value);
                initPuzzle();
            });

            shuffleButton.addEventListener('click', () => {
                shufflePuzzle();
            });
            
            selectImageButton.addEventListener('click', () => {
                imageInput.click();
            });

            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        cropperImage.src = event.target.result;
                        croppingModal.style.display = 'flex';

                        if (cropper) {
                            cropper.destroy();
                        }

                        cropper = new Cropper(cropperImage, {
                            aspectRatio: 1,
                            viewMode: 1,
                            dragMode: 'move',
                            minCropBoxWidth: 100,
                            minCropBoxHeight: 100,
                            autoCropArea: 0.8,
                            cropBoxMovable: true,
                            cropBoxResizable: true,
                        });
                    };
                    reader.readAsDataURL(file);
                }
                e.target.value = '';
            });

            cropButton.addEventListener('click', () => {
                if (cropper) {
                    const croppedCanvas = cropper.getCroppedCanvas({
                        width: 1000,
                        height: 1000,
                        imageSmoothingEnabled: false,
                        imageSmoothingQuality: 'high',
                    });

                    image.onload = () => {
                        IMAGE_SRC = croppedCanvas.toDataURL('image/jpeg');
                        initPuzzle();
                    };
                    image.src = croppedCanvas.toDataURL('image/jpeg');
                }
                
                croppingModal.style.display = 'none';
                if (cropper) {
                    cropper.destroy();
                }
            });

            closeModalButton.addEventListener('click', () => {
                croppingModal.style.display = 'none';
                if (cropper) {
                    cropper.destroy();
                }
            });

            function getTileByPosition(row, col) {
                return tiles.find(t => t.currentPos.row === row && t.currentPos.col === col);
            }
            
            function applyToNeighbors(row, col, action) {
                const neighbors = [
                    { r: row, c: col },
                    { r: row - 1, c: col },
                    { r: row + 1, c: col },
                    { r: row, c: col - 1 },
                    { r: row, c: col + 1 }
                ];
                neighbors.forEach(pos => {
                    if (pos.r >= 0 && pos.r < gridSize && pos.c >= 0 && pos.c < gridSize) {
                        const tile = getTileByPosition(pos.r, pos.c);
                        if (tile) {
                            action(tile);
                        }
                    }
                });
            }
            
            function updateMode(direction) {
                const currentIndex = modes.indexOf(gameMode);
                let nextIndex = (currentIndex + direction + modes.length) % modes.length;
                gameMode = modes[nextIndex];
                modeNameElement.textContent = `Режим: ${modeNames[gameMode]}`;
                initPuzzle();
            }

            modePrevButton.addEventListener('click', () => updateMode(-1));
            modeNextButton.addEventListener('click', () => updateMode(1));
            
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const clickedCol = Math.floor(x / tileWidth);
                const clickedRow = Math.floor(y / tileHeight);
                
                const clickedTile = tiles.find(t => t.currentPos.row === clickedRow && t.currentPos.col === clickedCol);
                
                if (!clickedTile || clickedTile.isAnimating) {
                    return;
                }
                
                if (isSolved && !timerInterval) {
                    isSolved = false;
                    startTimer();
                }

                if (gameMode === 'classic') {
                    const emptyRow = emptyTile.currentPos.row;
                    const emptyCol = emptyTile.currentPos.col;
                    const isAdjacent = (Math.abs(clickedRow - emptyRow) + Math.abs(clickedCol - emptyCol)) === 1;
                    if (isAdjacent) {
                        movesCount++;
                        startAnimation(clickedTile, 'slide', { 
                            col: emptyCol, 
                            row: emptyRow 
                        });
                    }
                } else if (gameMode === 'flips') {
                    movesCount++;
                    startAnimation(clickedTile, 'flip', { isFlippedVertical: !clickedTile.isFlippedVertical });
                } else if (gameMode === 'rotations') {
                    movesCount++;
                    startAnimation(clickedTile, 'rotate', { rotation: clickedTile.rotation + 90 });
                } else if (gameMode === 'flips+') {
                    movesCount++;
                    applyToNeighbors(clickedRow, clickedCol, (tile) => {
                        startAnimation(tile, 'flip', { isFlippedHorizontal: !tile.isFlippedHorizontal });
                    });
                } else if (gameMode === 'rotations+') {
                     movesCount++;
                     applyToNeighbors(clickedRow, clickedCol, (tile) => {
                        startAnimation(tile, 'rotate', { rotation: tile.rotation + 90 });
                     });
                }
            });

            // Обработчик для правого клика (контекстное меню)
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = (e.clientX - rect.left) * scaleX;
                const y = (e.clientY - rect.top) * scaleY;
                
                const clickedCol = Math.floor(x / tileWidth);
                const clickedRow = Math.floor(y / tileHeight);
                
                const clickedTile = getTileByPosition(clickedRow, clickedCol);
                
                if (!clickedTile || clickedTile.isAnimating) {
                    return;
                }
                
                if (isSolved && !timerInterval) {
                    isSolved = false;
                    startTimer();
                }

                if (gameMode === 'flips') {
                    movesCount++;
                    startAnimation(clickedTile, 'flip', { isFlippedHorizontal: !clickedTile.isFlippedHorizontal });
                } else if (gameMode === 'rotations') {
                    movesCount++;
                    startAnimation(clickedTile, 'rotate', { rotation: clickedTile.rotation - 90 });
                } else if (gameMode === 'flips+') {
                    movesCount++;
                    // Исправлено: ПКМ переворачивает по вертикали
                    applyToNeighbors(clickedRow, clickedCol, (tile) => {
                        startAnimation(tile, 'flip', { isFlippedVertical: !tile.isFlippedVertical });
                    });
                } else if (gameMode === 'rotations+') {
                    movesCount++;
                    applyToNeighbors(clickedRow, clickedCol, (tile) => {
                       startAnimation(tile, 'rotate', { rotation: tile.rotation - 90 });
                    });
                } else { 
                   return;
                }
            });

            // Функция запускает анимацию для конкретного тайла
            function startAnimation(tile, animationType, endState) {
                if (tile.isAnimating) return;

                if (!isAnimationsEnabled) {
                     // If animations are disabled, immediately apply the end state
                     if (animationType === 'slide') {
                         const startPos = { ...tile.currentPos };
                         tile.currentPos = { ...endState };
                         emptyTile.currentPos = startPos;
                     } else if (animationType === 'rotate') {
                         tile.rotation = (endState.rotation % 360 + 360) % 360;
                     } else if (animationType === 'flip') {
                         tile.isFlippedHorizontal = endState.isFlippedHorizontal !== undefined ? endState.isFlippedHorizontal : tile.isFlippedHorizontal;
                         tile.isFlippedVertical = endState.isFlippedVertical !== undefined ? endState.isFlippedVertical : tile.isFlippedVertical;
                     }
                     checkWin();
                     updateStats();
                     drawPuzzle();
                     return;
                }
                
                tile.isAnimating = true;
                tile.animationStartTime = performance.now();
                tile.animationType = animationType;

                if (animationType === 'slide') {
                    tile.startState = { ...tile.currentPos };
                    tile.endState = { ...endState };
                } else if (animationType === 'rotate') {
                    tile.startState = { rotation: tile.rotation };
                    tile.endState = { rotation: endState.rotation };
                    if (tile.endState.rotation === 0 && tile.startState.rotation === 270) {
                         tile.startState.rotation = -90; // Для плавности
                    }
                } else if (animationType === 'flip') {
                    tile.startState = { 
                        isFlippedHorizontal: tile.isFlippedHorizontal, 
                        isFlippedVertical: tile.isFlippedVertical 
                    };
                    tile.endState = { 
                        isFlippedHorizontal: endState.isFlippedHorizontal !== undefined ? endState.isFlippedHorizontal : tile.isFlippedHorizontal,
                        isFlippedVertical: endState.isFlippedVertical !== undefined ? endState.isFlippedVertical : tile.isFlippedVertical
                    };
                }
            }

            solveButton.addEventListener('click', () => {
                initPuzzle();
            });
            
            hintsButton.addEventListener('click', () => {
                showHints = !showHints;
                hintsButton.textContent = `Подсказки: ${showHints ? 'Вкл.' : 'Выкл.'}`;
                drawPuzzle();
            });

            resetStatsButton.addEventListener('click', () => {
                resetStats();
            });

            themeSwitcher.addEventListener('click', toggleTheme);

            // NEW: Animations toggle handler
            animationsButton.addEventListener('click', () => {
                isAnimationsEnabled = !isAnimationsEnabled;
                animationsButton.textContent = `Анимации: ${isAnimationsEnabled ? 'Вкл.' : 'Выкл.'}`;
                // This will force the next frame to be drawn without animation if disabled
                drawPuzzle(); 
            });
            
            setupGame();
        });
    </script>
</body>
</html>
