
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.6.1/cropper.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: #1a202c;
            color: #e2e8f0;
        }

        .no-select {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        #game-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
        }

        @media (min-width: 1024px) {
            #game-container {
                flex-direction: row;
                justify-content: center;
                align-items: center;
            }
        }

        #controls {
            background-color: #2d3748;
            border-radius: 1rem;
            padding: 1.5rem;
            width: 100%;
            max-width: 300px;
            margin-bottom: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        @media (min-width: 1024px) {
            #controls {
                margin-right: 2rem;
                margin-bottom: 0;
            }
        }
        
        .control-group {
            margin-bottom: 1rem;
        }

        .control-label {
            font-size: 0.875rem;
            color: #a0aec0;
            margin-bottom: 0.5rem;
        }
        
        .control-button {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .control-button:hover:not(:disabled) {
            background-color: #636b77;
        }
        
        .control-button:active:not(:disabled) {
            transform: scale(0.98);
        }

        .control-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .mode-button-nav {
            background-color: #4a5568;
            color: #e2e8f0;
            padding: 0.25rem 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }

        .mode-button-nav:hover:not(:disabled) {
            background-color: #636b77;
        }

        .mode-button-nav:active:not(:disabled) {
            transform: scale(0.95);
        }

        #game-canvas {
            border-radius: 1rem;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.3);
            transition: border-color 0.5s ease;
            touch-action: none; /* Prevent browser touch actions */
        }

        .status-border-unsolved {
            border: 5px solid #e53e3e; /* Red */
        }
        .status-border-solved {
            border: 5px solid #48bb78; /* Green */
        }

        #info-panel {
            background-color: #2d3748;
            border-radius: 1rem;
            padding: 1rem;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        #cropper-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .cropper-container {
            max-width: 90%;
            max-height: 90%;
            display: flex;
            flex-direction: column;
            background-color: #1a202c;
            border-radius: 1rem;
            padding: 1rem;
        }

        #cropper-image {
            max-width: 100%;
            max-height: 80vh;
        }

        .cropper-buttons {
            display: flex;
            justify-content: flex-end;
            margin-top: 1rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-inter">
    <div id="game-container">

        <!-- Панель управления -->
        <div id="controls" class="no-select">
            <h2 class="text-xl font-bold mb-4">Управление</h2>

            <!-- Загрузка изображения -->
            <div class="control-group">
                <label for="image-upload" class="control-label">Загрузить изображение</label>
                <button onclick="document.getElementById('image-upload').click()" class="control-button w-full">Выбрать файл</button>
                <input type="file" id="image-upload" class="hidden" accept="image/*">
            </div>

            <!-- Переключение режима -->
            <div class="control-group">
                <div class="control-label">Режим игры</div>
                <div class="flex items-center justify-between mt-2">
                    <button id="prev-mode-btn" class="mode-button-nav" disabled>&lt;</button>
                    <span id="current-mode-display" class="font-bold text-center mx-2">Перевороты</span>
                    <button id="next-mode-btn" class="mode-button-nav" disabled>&gt;</button>
                </div>
            </div>

            <!-- Выбор размера поля -->
            <div class="control-group">
                <div class="control-label">Размер поля</div>
                <select id="grid-size-select" class="w-full mt-2 bg-gray-700 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 transition-colors">
                    <option value="2">2x2</option>
                    <option value="3" selected>3x3</option>
                    <option value="4">4x4</option>
                    <option value="5">5x5</option>
                    <option value="6">6x6</option>
                    <option value="7">7x7</option>
                    <option value="8">8x8</option>
                    <option value="9">9x9</option>
                    <option value="10">10x10</option>
                    <option value="11">11x11</option>
                    <option value="12">12x12</option>
                    <option value="13">13x13</option>
                    <option value="14">14x14</option>
                    <option value="15">15x15</option>
                    <option value="16">16x16</option>
                </select>
            </div>

            <!-- Переключатели -->
            <div class="control-group flex items-center justify-between">
                <div class="control-label mb-0">Анимации</div>
                <input type="checkbox" id="animation-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded" checked>
            </div>
            <div class="control-group flex items-center justify-between">
                <div class="control-label mb-0">Подсказки</div>
                <input type="checkbox" id="hints-toggle" class="form-checkbox h-5 w-5 text-blue-600 rounded">
            </div>

            <!-- Кнопки действий -->
            <div class="control-group flex justify-between gap-2 mt-4">
                <button id="shuffle-btn" class="control-button flex-1">Перемешать</button>
                <button id="solve-btn" class="control-button flex-1">Собрать</button>
            </div>
        </div>

        <!-- Информация о игре -->
        <div id="info-panel" class="no-select">
            <h3 class="text-lg font-bold mb-2">Статистика</h3>
            <div class="info-item">
                <span class="text-sm">Не на своём месте:</span>
                <span id="tiles-out-of-place-count" class="font-bold text-xl">0</span>
            </div>
            <div class="info-item">
                <span class="text-sm">Ходов:</span>
                <span id="moves-count" class="font-bold text-xl">0</span>
            </div>
            <div class="info-item">
                <span class="text-sm">Время:</span>
                <span id="timer-display" class="font-bold text-xl">00:00</span>
            </div>
        </div>
        
        <!-- Canvas -->
        <canvas id="game-canvas" class="lg:h-screen lg:w-auto w-full h-auto max-w-full max-h-full aspect-square bg-gray-800 rounded-2xl status-border-unsolved transition-all duration-500"></canvas>
    </div>

    <!-- Модальное окно для кадрирования -->
    <div id="cropper-modal" class="hidden">
        <div class="cropper-container">
            <h2 class="text-xl font-bold mb-4">Кадрировать изображение</h2>
            <div class="cropper-box flex-1 w-full flex items-center justify-center">
                <img id="cropper-image" src="#" alt="Image to crop">
            </div>
            <div class="cropper-buttons">
                <button id="crop-cancel-btn" class="control-button mr-2">Отмена</button>
                <button id="crop-confirm-btn" class="control-button">Готово</button>
            </div>
        </div>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Глобальные переменные и состояние игры ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const imageUpload = document.getElementById('image-upload');
        const cropperModal = document.getElementById('cropper-modal');
        const cropperImage = document.getElementById('cropper-image');
        const cropConfirmBtn = document.getElementById('crop-confirm-btn');
        const cropCancelBtn = document.getElementById('crop-cancel-btn');
        const modes = ['Перевороты', 'Перевороты+', 'Повороты', 'Повороты+', 'Пятнашки', 'Перетаскивание'];
        let cropper;

        let gameState = {
            modeIndex: 0,
            gridSize: 3,
            isAnimationEnabled: true,
            isHintsEnabled: false,
            isSolved: false,
            moves: 0,
            timer: 0,
            timerId: null,
            image: new Image(),
            tiles: [],
            isDragging: false,
            draggedTile: null,
            dragStartX: 0,
            dragStartY: 0,
            dragOffsetX: 0,
            dragOffsetY: 0,
            emptyTileIndex: 0,
            animationQueue: [],
            isAnimating: false,
            animationStart: 0,
        };

        const uiElements = {
            modeDisplay: document.getElementById('current-mode-display'),
            prevModeBtn: document.getElementById('prev-mode-btn'),
            nextModeBtn: document.getElementById('next-mode-btn'),
            gridSizeSelect: document.getElementById('grid-size-select'),
            animationToggle: document.getElementById('animation-toggle'),
            hintsToggle: document.getElementById('hints-toggle'),
            shuffleBtn: document.getElementById('shuffle-btn'),
            solveBtn: document.getElementById('solve-btn'),
            tilesOutOfPlaceCount: document.getElementById('tiles-out-of-place-count'),
            movesCount: document.getElementById('moves-count'),
            timerDisplay: document.getElementById('timer-display'),
        };

        const defaultImageUrl = "https://placehold.co/1024x1024/2d3748/e2e8f0?text=Загрузите+изображение";

        // --- Управление UI и события ---

        uiElements.prevModeBtn.addEventListener('click', () => {
            gameState.modeIndex = (gameState.modeIndex - 1 + modes.length) % modes.length;
            updateMode();
        });

        uiElements.nextModeBtn.addEventListener('click', () => {
            gameState.modeIndex = (gameState.modeIndex + 1) % modes.length;
            updateMode();
        });

        uiElements.gridSizeSelect.addEventListener('change', (e) => {
            gameState.gridSize = parseInt(e.target.value);
            resetGame();
        });

        uiElements.animationToggle.addEventListener('change', (e) => {
            gameState.isAnimationEnabled = e.target.checked;
        });

        uiElements.hintsToggle.addEventListener('change', (e) => {
            gameState.isHintsEnabled = e.target.checked;
            draw();
        });

        uiElements.shuffleBtn.addEventListener('click', shuffleTiles);

        uiElements.solveBtn.addEventListener('click', () => {
            resetTiles();
            checkWin();
            draw();
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    cropperImage.src = event.target.result;
                    cropperModal.classList.remove('hidden');
                    if (cropper) {
                        cropper.destroy();
                    }
                    cropper = new Cropper(cropperImage, {
                        aspectRatio: 1,
                        viewMode: 1,
                        autoCropArea: 1,
                        background: false,
                    });
                };
                reader.readAsDataURL(file);
            }
        });

        cropConfirmBtn.addEventListener('click', () => {
            const croppedCanvas = cropper.getCroppedCanvas();
            gameState.image.onload = () => {
                cropperModal.classList.add('hidden');
                resetGame();
            };
            gameState.image.src = croppedCanvas.toDataURL();
        });

        cropCancelBtn.addEventListener('click', () => {
            cropperModal.classList.add('hidden');
        });

        // --- Инициализация игры ---

        function init() {
            gameState.image.src = defaultImageUrl;
            gameState.image.onload = () => {
                resizeCanvas();
                resetGame();
            };
            window.addEventListener('resize', resizeCanvas);
            updateMode();
            setupInputListeners();
            animate();
        }

        // --- Игровая логика ---

        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerRect = container.getBoundingClientRect();
            const controlWidth = document.getElementById('controls').offsetWidth + 32; // 32 = 2rem margin
            let size = Math.min(window.innerWidth - controlWidth - 64, window.innerHeight - 64);
            if (window.innerWidth < 1024) { // Mobile layout
                size = Math.min(window.innerWidth - 32, window.innerHeight - 32 - document.getElementById('controls').offsetHeight - document.getElementById('info-panel').offsetHeight);
            }

            canvas.width = size;
            canvas.height = size;
            draw();
        }

        function resetGame() {
            resetStats();
            createTiles();
            draw();
        }

        function resetStats() {
            gameState.moves = 0;
            gameState.timer = 0;
            gameState.isSolved = false;
            if (gameState.timerId) clearInterval(gameState.timerId);
            updateUI();
        }

        function createTiles() {
            const n = gameState.gridSize;
            gameState.tiles = [];
            for (let i = 0; i < n * n; i++) {
                gameState.tiles.push({
                    id: i,
                    position: i,
                    initialPosition: i,
                    rotation: 0,
                    flippedX: false,
                    flippedY: false,
                    animating: false,
                    animProgress: 0,
                    startTransform: {},
                    endTransform: {},
                    targetPosition: i,
                    isCorrect: i === i, // For initial state
                });
            }
            gameState.emptyTileIndex = n * n - 1;
            gameState.tiles[gameState.emptyTileIndex].position = -1; // Special position for the empty tile
        }

        function shuffleTiles() {
            resetStats();
            const n = gameState.gridSize;
            let flatTiles = gameState.tiles.slice();
            const emptyTile = flatTiles.pop();
            flatTiles = shuffleArray(flatTiles);

            if (modes[gameState.modeIndex].includes('Пятнашки')) {
                // Пятнашки: Ensure solvability
                let isSolvable = false;
                while (!isSolvable) {
                    let inversions = 0;
                    for (let i = 0; i < flatTiles.length; i++) {
                        for (let j = i + 1; j < flatTiles.length; j++) {
                            if (flatTiles[i].id > flatTiles[j].id) {
                                inversions++;
                            }
                        }
                    }
                    if (n % 2 !== 0) { // Odd grid size
                        isSolvable = inversions % 2 === 0;
                    } else { // Even grid size
                        const emptyRow = Math.floor(n * n / 2 / n); // Simplified for a solvable config
                        isSolvable = (inversions + emptyRow) % 2 === 0;
                    }
                    if (!isSolvable) {
                        flatTiles = shuffleArray(flatTiles);
                    }
                }
            }

            // Assign new positions
            flatTiles.push(emptyTile);
            gameState.tiles = flatTiles.map((tile, index) => {
                tile.position = index;
                tile.isCorrect = checkTileCorrect(tile);
                tile.rotation = 0;
                tile.flippedX = false;
                tile.flippedY = false;
                return tile;
            });

            // Set the empty tile position correctly
            const emptyTileObj = gameState.tiles.find(t => t.id === gameState.emptyTileIndex);
            if (emptyTileObj) emptyTileObj.position = gameState.emptyTileIndex;

            // Start timer
            if (!gameState.timerId) {
                gameState.timerId = setInterval(() => {
                    gameState.timer++;
                    updateUI();
                }, 1000);
            }
            checkWin();
            draw();
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function checkWin() {
            gameState.isSolved = gameState.tiles.every(tile => checkTileCorrect(tile));
            updateUI();
        }

        function checkTileCorrect(tile) {
            const mode = modes[gameState.modeIndex];
            if (tile.id === -1) return true; // Empty tile is always correct

            let isPositionCorrect = tile.position === tile.id;
            let isOrientationCorrect = true;

            if (mode.includes('Повороты')) {
                isOrientationCorrect = tile.rotation === 0;
            } else if (mode.includes('Перевороты')) {
                isOrientationCorrect = !tile.flippedX && !tile.flippedY;
            }

            if (mode === 'Пятнашки' || mode === 'Перетаскивание') {
                isOrientationCorrect = true;
            }

            return isPositionCorrect && isOrientationCorrect;
        }

        // --- Логика рендеринга ---

        function draw() {
            if (!canvas || !ctx || !gameState.image) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const n = gameState.gridSize;
            const tileSize = canvas.width / n;

            const mode = modes[gameState.modeIndex];

            gameState.tiles.forEach(tile => {
                if (tile.position === -1) return; // Skip empty tile

                const currentPosition = tile.position;
                const row = Math.floor(currentPosition / n);
                const col = currentPosition % n;
                let x = col * tileSize;
                let y = row * tileSize;

                const originalRow = Math.floor(tile.id / n);
                const originalCol = tile.id % n;

                ctx.save();

                if (tile.animating && gameState.isAnimationEnabled) {
                    const animTime = Date.now() - gameState.animationStart;
                    let progress = Math.min(animTime / 300, 1);
                    tile.animProgress = progress;

                    const animType = tile.animType;
                    const start = tile.startTransform;
                    const end = tile.endTransform;

                    if (animType === 'slide') {
                        x = start.x + (end.x - start.x) * progress;
                        y = start.y + (end.y - start.y) * progress;
                    } else if (animType === 'rotate') {
                        const currentRotation = start.rotation + (end.rotation - start.rotation) * progress;
                        ctx.translate(x + tileSize / 2, y + tileSize / 2);
                        ctx.rotate(currentRotation * Math.PI / 180);
                        ctx.translate(-(x + tileSize / 2), -(y + tileSize / 2));
                    } else if (animType === 'flip') {
                        let scaleX = start.scaleX + (end.scaleX - start.scaleX) * progress;
                        let scaleY = start.scaleY + (end.scaleY - start.scaleY) * progress;
                        ctx.translate(x + tileSize / 2, y + tileSize / 2);
                        ctx.scale(scaleX, scaleY);
                        ctx.translate(-(x + tileSize / 2), -(y + tileSize / 2));
                    }
                    
                    if (progress === 1) {
                        tile.animating = false;
                        if (gameState.animationQueue.length > 0) {
                            const nextAnim = gameState.animationQueue.shift();
                            startAnimation(nextAnim.tile, nextAnim.type, nextAnim.from, nextAnim.to);
                        } else {
                            gameState.isAnimating = false;
                        }
                    }
                }

                if (gameState.isDragging && tile === gameState.draggedTile) {
                    x = gameState.draggedTile.dragX;
                    y = gameState.draggedTile.dragY;
                }

                ctx.drawImage(
                    gameState.image,
                    originalCol * (gameState.image.width / n),
                    originalRow * (gameState.image.height / n),
                    gameState.image.width / n,
                    gameState.image.height / n,
                    x, y,
                    tileSize, tileSize
                );

                ctx.restore();

                // Рисование подсказок и рамок
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#374151'; // Gray border
                ctx.strokeRect(x, y, tileSize, tileSize);

                if (gameState.isHintsEnabled) {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = checkTileCorrect(tile) ? '#48bb78' : '#e53e3e';
                    ctx.strokeRect(x, y, tileSize, tileSize);

                    if (mode.includes('Пятнашки') || mode === 'Перетаскивание') {
                        ctx.font = `${tileSize * 0.25}px Inter`;
                        ctx.fillStyle = checkTileCorrect(tile) ? '#48bb78' : '#e53e3e';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(tile.id + 1, x + tileSize / 2, y + tileSize / 2);
                    } else if (mode.includes('Повороты')) {
                        const arrowSize = tileSize * 0.2;
                        const arrowX = x + tileSize / 2;
                        const arrowY = y + tileSize / 2;
                        
                        ctx.save();
                        ctx.translate(arrowX, arrowY);
                        ctx.rotate(tile.rotation * Math.PI / 180);
                        
                        ctx.fillStyle = checkTileCorrect(tile) ? '#48bb78' : '#e53e3e';
                        ctx.beginPath();
                        ctx.moveTo(0, -arrowSize);
                        ctx.lineTo(arrowSize * 0.4, 0);
                        ctx.lineTo(-arrowSize * 0.4, 0);
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();
                    }
                }
            });
        }

        function animate() {
            if (gameState.isAnimating) {
                draw();
            }
            requestAnimationFrame(animate);
        }

        // --- Управление анимацией ---

        function startAnimation(tile, type, from, to) {
            if (!gameState.isAnimationEnabled) {
                tile.animating = false;
                if (type === 'slide') tile.position = to.position;
                else if (type === 'rotate') tile.rotation = to.rotation;
                else if (type === 'flip') {
                    tile.flippedX = to.flippedX;
                    tile.flippedY = to.flippedY;
                }
                draw();
                return;
            }
            
            tile.animating = true;
            tile.animType = type;
            gameState.animationStart = Date.now();
            gameState.isAnimating = true;

            const n = gameState.gridSize;
            const tileSize = canvas.width / n;

            if (type === 'slide') {
                const fromRow = Math.floor(from.position / n);
                const fromCol = from.position % n;
                const toRow = Math.floor(to.position / n);
                const toCol = to.position % n;

                tile.startTransform = { x: fromCol * tileSize, y: fromRow * tileSize };
                tile.endTransform = { x: toCol * tileSize, y: toRow * tileSize };
            } else if (type === 'rotate') {
                tile.startTransform = { rotation: from.rotation };
                tile.endTransform = { rotation: to.rotation };
            } else if (type === 'flip') {
                tile.startTransform = { scaleX: from.flippedX ? -1 : 1, scaleY: from.flippedY ? -1 : 1 };
                tile.endTransform = { scaleX: to.flippedX ? -1 : 1, scaleY: to.flippedY ? -1 : 1 };
            }
        }

        // --- Управление вводом (мышь и тач) ---

        function getTileIndexFromCoords(x, y) {
            const n = gameState.gridSize;
            const tileSize = canvas.width / n;
            const col = Math.floor((x - canvas.offsetLeft) / tileSize);
            const row = Math.floor((y - canvas.offsetTop) / tileSize);
            
            // Find the tile at the clicked position
            return gameState.tiles.findIndex(tile => {
                const tileRow = Math.floor(tile.position / n);
                const tileCol = tile.position % n;
                return tileRow === row && tileCol === col && tile.position !== -1;
            });
        }

        function setupInputListeners() {
            canvas.addEventListener('contextmenu', e => e.preventDefault());
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', handleInput);
            canvas.addEventListener('mousemove', handleDrag);
            canvas.addEventListener('touchmove', handleDrag);
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('touchend', handleDragEnd);
        }

        function handleInput(e) {
            const mode = modes[gameState.modeIndex];
            const isTouch = e.type.startsWith('touch');
            const touch = isTouch ? e.touches[0] : null;
            const x = isTouch ? touch.clientX : e.clientX;
            const y = isTouch ? touch.clientY : e.clientY;

            const tileIndex = getTileIndexFromCoords(x, y);
            if (tileIndex === -1) return;
            const tile = gameState.tiles[tileIndex];

            // Interrupt any ongoing animation
            if (tile.animating) {
                // Instantly complete the animation
                tile.animating = false;
                if (tile.animType === 'slide') tile.position = tile.targetPosition;
                draw();
            }

            // Game logic based on mode
            if (mode.includes('Перетаскивание')) {
                gameState.isDragging = true;
                gameState.draggedTile = tile;
                gameState.dragStartX = x;
                gameState.dragStartY = y;
                e.preventDefault();
            } else if (mode.includes('Пятнашки')) {
                const n = gameState.gridSize;
                const tilePos = tile.position;
                const emptyTilePos = gameState.tiles.find(t => t.id === gameState.emptyTileIndex).position;

                const dx = Math.abs((tilePos % n) - (emptyTilePos % n));
                const dy = Math.abs(Math.floor(tilePos / n) - Math.floor(emptyTilePos / n));

                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    swapTiles(tile, gameState.tiles.find(t => t.id === gameState.emptyTileIndex));
                }
            } else if (mode.includes('Повороты')) {
                const rotation = e.button === 2 ? -90 : 90; // Right click for -90, left for 90
                rotateTiles(tile, rotation, mode.includes('+'));
                e.preventDefault(); // Prevent context menu on right click
            } else if (mode.includes('Перевороты')) {
                const flipX = e.button === 2; // Right click for horizontal flip
                const flipY = e.button !== 2; // Left click for vertical flip
                flipTiles(tile, flipX, flipY, mode.includes('+'));
                e.preventDefault(); // Prevent context menu
            }

            gameState.moves++;
            checkWin();
            updateUI();
        }

        function handleDrag(e) {
            if (!gameState.isDragging || modes[gameState.modeIndex] !== 'Перетаскивание') return;
            const isTouch = e.type.startsWith('touch');
            const touch = isTouch ? e.touches[0] : null;
            const x = isTouch ? touch.clientX : e.clientX;
            const y = isTouch ? touch.clientY : e.clientY;

            const dx = x - gameState.dragStartX;
            const dy = y - gameState.dragStartY;

            const tile = gameState.draggedTile;
            const n = gameState.gridSize;
            const tileSize = canvas.width / n;
            const row = Math.floor(tile.position / n);
            const col = tile.position % n;

            tile.dragX = col * tileSize + dx;
            tile.dragY = row * tileSize + dy;
            draw();
            e.preventDefault();
        }

        function handleDragEnd(e) {
            if (!gameState.isDragging) return;

            const isTouch = e.type.startsWith('touch');
            const touch = isTouch ? e.changedTouches[0] : null;
            const x = isTouch ? touch.clientX : e.clientX;
            const y = isTouch ? touch.clientY : e.clientY;

            const n = gameState.gridSize;
            const tileSize = canvas.width / n;

            const newTileCol = Math.floor((x - canvas.offsetLeft + tileSize / 2) / tileSize);
            const newTileRow = Math.floor((y - canvas.offsetTop + tileSize / 2) / tileSize);
            const newPosition = newTileRow * n + newTileCol;

            const draggedTile = gameState.draggedTile;
            const targetTile = gameState.tiles.find(t => t.position === newPosition);

            if (targetTile && draggedTile.position !== newPosition) {
                // Swap tiles
                startAnimation(draggedTile, 'slide', { position: draggedTile.position }, { position: newPosition });
                startAnimation(targetTile, 'slide', { position: newPosition }, { position: draggedTile.position });
                
                const tempPos = draggedTile.position;
                draggedTile.position = targetTile.position;
                targetTile.position = tempPos;
            } else {
                // Snap back to original position with animation
                startAnimation(draggedTile, 'slide', { position: draggedTile.position }, { position: draggedTile.position });
            }

            gameState.isDragging = false;
            gameState.draggedTile = null;
            checkWin();
            updateUI();
        }

        function swapTiles(tileA, tileB) {
            const tempPos = tileA.position;
            
            startAnimation(tileA, 'slide', { position: tileA.position }, { position: tileB.position });
            startAnimation(tileB, 'slide', { position: tileB.position }, { position: tempPos });

            tileA.position = tileB.position;
            tileB.position = tempPos;
        }

        function rotateTiles(tile, rotation, rotateNeighbors) {
            const tilesToRotate = [tile];
            if (rotateNeighbors) {
                const n = gameState.gridSize;
                const row = Math.floor(tile.position / n);
                const col = tile.position % n;
                const neighbors = [
                    { r: row - 1, c: col }, { r: row + 1, c: col },
                    { r: row, c: col - 1 }, { r: row, c: col + 1 }
                ];
                neighbors.forEach(nPos => {
                    const neighborTile = gameState.tiles.find(t => Math.floor(t.position / n) === nPos.r && (t.position % n) === nPos.c);
                    if (neighborTile) tilesToRotate.push(neighborTile);
                });
            }

            tilesToRotate.forEach(t => {
                const newRotation = (t.rotation + rotation) % 360;
                startAnimation(t, 'rotate', { rotation: t.rotation }, { rotation: newRotation });
                t.rotation = newRotation;
                t.isCorrect = checkTileCorrect(t);
            });
            draw();
        }

        function flipTiles(tile, flipX, flipY, flipNeighbors) {
            const tilesToFlip = [tile];
            if (flipNeighbors) {
                const n = gameState.gridSize;
                const row = Math.floor(tile.position / n);
                const col = tile.position % n;
                const neighbors = [
                    { r: row - 1, c: col }, { r: row + 1, c: col },
                    { r: row, c: col - 1 }, { r: row, c: col + 1 }
                ];
                neighbors.forEach(nPos => {
                    const neighborTile = gameState.tiles.find(t => Math.floor(t.position / n) === nPos.r && (t.position % n) === nPos.c);
                    if (neighborTile) tilesToFlip.push(neighborTile);
                });
            }

            tilesToFlip.forEach(t => {
                if (flipX) t.flippedX = !t.flippedX;
                if (flipY) t.flippedY = !t.flippedY;
                startAnimation(t, 'flip', { flippedX: !flipX, flippedY: !flipY }, { flippedX, flippedY });
                t.isCorrect = checkTileCorrect(t);
            });
            draw();
        }

        // --- Обновление UI ---

        function updateMode() {
            uiElements.modeDisplay.textContent = modes[gameState.modeIndex];
            const isPuzzleMode = modes[gameState.modeIndex].includes('Пятнашки') || modes[gameState.modeIndex].includes('Перетаскивание');
            uiElements.shuffleBtn.disabled = !isPuzzleMode;
            uiElements.solveBtn.disabled = !isPuzzleMode;
        }

        function updateUI() {
            const tilesOutOfPlace = gameState.tiles.filter(t => !checkTileCorrect(t)).length;
            uiElements.tilesOutOfPlaceCount.textContent = tilesOutOfPlace;
            uiElements.movesCount.textContent = gameState.moves;

            const minutes = Math.floor(gameState.timer / 60).toString().padStart(2, '0');
            const seconds = (gameState.timer % 60).toString().padStart(2, '0');
            uiElements.timerDisplay.textContent = `${minutes}:${seconds}`;

            if (gameState.isSolved) {
                canvas.classList.remove('status-border-unsolved');
                canvas.classList.add('status-border-solved');
            } else {
                canvas.classList.remove('status-border-solved');
                canvas.classList.add('status-border-unsolved');
            }
        }

        init();
    });
</script>
</body>
</html>
